{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HiveMind Community Documentation Welcome to the HiveMind Community Docs! HiveMind is a community-developed superset or extension of OpenVoiceOS the open-source voice operating system. With HiveMind, you can extend one (or more, but usually just one!) instance of OpenVoiceOS to as many devices as you want, including devices that can't ordinarily run OpenVoiceOS! HiveMind's developers have successfully connected to OpenVoiceOS from a PinePhone, a 2009 MacBook, and a Raspberry Pi 0, among other devices. OpenVoiceOS itself usually runs on our desktop computers or our home servers, but you can use any Mycroft-branded device, or OpenVoiceOS , as your central unit. Join Hivemind Matrix chat for general news, support and chit chat","title":"Home"},{"location":"#hivemind-community-documentation","text":"Welcome to the HiveMind Community Docs! HiveMind is a community-developed superset or extension of OpenVoiceOS the open-source voice operating system. With HiveMind, you can extend one (or more, but usually just one!) instance of OpenVoiceOS to as many devices as you want, including devices that can't ordinarily run OpenVoiceOS! HiveMind's developers have successfully connected to OpenVoiceOS from a PinePhone, a 2009 MacBook, and a Raspberry Pi 0, among other devices. OpenVoiceOS itself usually runs on our desktop computers or our home servers, but you can use any Mycroft-branded device, or OpenVoiceOS , as your central unit. Join Hivemind Matrix chat for general news, support and chit chat","title":"HiveMind Community Documentation"},{"location":"00_index/","text":"HiveMind Community Documentation Welcome to the HiveMind Community Docs! HiveMind is a community-developed superset or extension of OpenVoiceOS the open-source voice operating system. With HiveMind, you can extend one (or more, but usually just one!) instance of OpenVoiceOS to as many devices as you want, including devices that can't ordinarily run OpenVoiceOS! HiveMind's developers have successfully connected to OpenVoiceOS from a PinePhone, a 2009 MacBook, and a Raspberry Pi 0, among other devices. OpenVoiceOS itself usually runs on our desktop computers or our home servers, but you can use any Mycroft-branded device, or OpenVoiceOS , as your central unit. Join Hivemind Matrix chat for general news, support and chit chat","title":"HiveMind Community Documentation"},{"location":"00_index/#hivemind-community-documentation","text":"Welcome to the HiveMind Community Docs! HiveMind is a community-developed superset or extension of OpenVoiceOS the open-source voice operating system. With HiveMind, you can extend one (or more, but usually just one!) instance of OpenVoiceOS to as many devices as you want, including devices that can't ordinarily run OpenVoiceOS! HiveMind's developers have successfully connected to OpenVoiceOS from a PinePhone, a 2009 MacBook, and a Raspberry Pi 0, among other devices. OpenVoiceOS itself usually runs on our desktop computers or our home servers, but you can use any Mycroft-branded device, or OpenVoiceOS , as your central unit. Join Hivemind Matrix chat for general news, support and chit chat","title":"HiveMind Community Documentation"},{"location":"01_quickstart/","text":"Quick Start Guide This guide will help you get started quickly with the HiveMind platform, allowing you to extend your OpenVoiceOS (OVOS) ecosystem across multiple devices, even with low-resource hardware. HiveMind lets you connect lightweight devices as satellites to a central OVOS hub, offering centralized control and fine-grained permissions. \ud83d\ude80 Installation To begin using HiveMind Core, you need to install the hivemind-core package in your OVOS device. This can be done via pip: pip install hivemind-core \ud83d\udef0\ufe0f Adding a Satellite Device Once the server is running, you'll need to add client credentials for each satellite device you want to connect. Run the following command to add a satellite device: hivemind-core add-client The output wi*ll show you important details like: Node ID Friendly Name Access Key Password Encryption Key (deprecated, only used for legacy clients) Provide these credentials on the client devices to enable the connection. \ud83d\udda5\ufe0f Running the HiveMind Server Start the HiveMind server to accept client connections on a specified port: hivemind-core listen --port 5678 The server will now listen for incoming satellite connections. \ud83d\udca1 hivemind-core needs to be running in the same device as OVOS \ud83d\udd11 Permissions HiveMind Core uses a flexible permissions system, where each client's permissions are customizable. By default: Only essential bus messages are allowed. Skills and intents are accessible but can be blacklisted or restricted. You can manage permissions for clients by using commands like allow-msg , blacklist-msg , allow-skill , and blacklist-skill . Example Use Cases: Basic AI Integration : Enable a simple client to send natural language instructions. Custom Permissions : Restrict an IoT device to only communicate with specific message types, such as temperature.set . HiveMind Core Commands Overview Here are the basic commands for managing clients and their permissions: Add a new client : hivemind-core add-client --name \"satellite_1\" --access-key \"mykey123\" --password \"mypass\" List all registered clients : hivemind-core list-clients Start listening for client connections : hivemind-core listen --port 5678 For detailed help on each command, use --help (e.g., hivemind-core add-client --help ).","title":"Quick start"},{"location":"01_quickstart/#quick-start-guide","text":"This guide will help you get started quickly with the HiveMind platform, allowing you to extend your OpenVoiceOS (OVOS) ecosystem across multiple devices, even with low-resource hardware. HiveMind lets you connect lightweight devices as satellites to a central OVOS hub, offering centralized control and fine-grained permissions.","title":"Quick Start Guide"},{"location":"01_quickstart/#installation","text":"To begin using HiveMind Core, you need to install the hivemind-core package in your OVOS device. This can be done via pip: pip install hivemind-core","title":"\ud83d\ude80 Installation"},{"location":"01_quickstart/#adding-a-satellite-device","text":"Once the server is running, you'll need to add client credentials for each satellite device you want to connect. Run the following command to add a satellite device: hivemind-core add-client The output wi*ll show you important details like: Node ID Friendly Name Access Key Password Encryption Key (deprecated, only used for legacy clients) Provide these credentials on the client devices to enable the connection.","title":"\ud83d\udef0\ufe0f Adding a Satellite Device"},{"location":"01_quickstart/#running-the-hivemind-server","text":"Start the HiveMind server to accept client connections on a specified port: hivemind-core listen --port 5678 The server will now listen for incoming satellite connections. \ud83d\udca1 hivemind-core needs to be running in the same device as OVOS","title":"\ud83d\udda5\ufe0f Running the HiveMind Server"},{"location":"01_quickstart/#permissions","text":"HiveMind Core uses a flexible permissions system, where each client's permissions are customizable. By default: Only essential bus messages are allowed. Skills and intents are accessible but can be blacklisted or restricted. You can manage permissions for clients by using commands like allow-msg , blacklist-msg , allow-skill , and blacklist-skill .","title":"\ud83d\udd11 Permissions"},{"location":"01_quickstart/#example-use-cases","text":"Basic AI Integration : Enable a simple client to send natural language instructions. Custom Permissions : Restrict an IoT device to only communicate with specific message types, such as temperature.set .","title":"Example Use Cases:"},{"location":"01_quickstart/#hivemind-core-commands-overview","text":"Here are the basic commands for managing clients and their permissions: Add a new client : hivemind-core add-client --name \"satellite_1\" --access-key \"mykey123\" --password \"mypass\" List all registered clients : hivemind-core list-clients Start listening for client connections : hivemind-core listen --port 5678 For detailed help on each command, use --help (e.g., hivemind-core add-client --help ).","title":"HiveMind Core Commands Overview"},{"location":"02_terminology/","text":"Terminology Before we delve into the depths of the Hivemind Protocol, let's familiarize ourselves with some key terms used within the ecosystem: Node : A device or software client that is part of to the Hivemind network. Mind : A node that actively listens for connections and understands natural language commands. Minds communicate via BUS messages , authenticate other nodes, isolate connections, and authorize individual messages Fakecroft : A mind that imitates ovos-core without actually running it. often only handles a subset of BUS messages , usually only \"speak\" and \"recognizer_loop:utterance\" Terminal : A user-facing node that connects to a mind but doesn't accept connections itself. Bridge : A node that links an external service to a mind. Hive : A collection of interconnected nodes forming a collaborative network. Slave : A mind that connects to another mind and always accepts BUS messages from it. NOTE: A Terminal is like a Slave, but it is NOT a Mind Master Mind : The highest-level node in a hive that is not connected to any other nodes but receives connections from other nodes. The Collective : The collection of all Master Minds in the world","title":"Terminology"},{"location":"02_terminology/#terminology","text":"Before we delve into the depths of the Hivemind Protocol, let's familiarize ourselves with some key terms used within the ecosystem: Node : A device or software client that is part of to the Hivemind network. Mind : A node that actively listens for connections and understands natural language commands. Minds communicate via BUS messages , authenticate other nodes, isolate connections, and authorize individual messages Fakecroft : A mind that imitates ovos-core without actually running it. often only handles a subset of BUS messages , usually only \"speak\" and \"recognizer_loop:utterance\" Terminal : A user-facing node that connects to a mind but doesn't accept connections itself. Bridge : A node that links an external service to a mind. Hive : A collection of interconnected nodes forming a collaborative network. Slave : A mind that connects to another mind and always accepts BUS messages from it. NOTE: A Terminal is like a Slave, but it is NOT a Mind Master Mind : The highest-level node in a hive that is not connected to any other nodes but receives connections from other nodes. The Collective : The collection of all Master Minds in the world","title":"Terminology"},{"location":"03_pairing/","text":"Pairing devices You can register clients in a Mind via command line or via audio Command Line Pairing First, you need to register the satellite devices in the HiveMind server $ hivemind-core add-client Credentials added to database! Node ID: 2 Friendly Name: HiveMind-Node-2 Access Key: 5a9e580a2773a262cbb23fe9759881ff Password: 9b247ca66c7cd2b6388ad49ca504279d Encryption Key: 4185240103de0770 WARNING: Encryption Key is deprecated, only use if your client does not support password And then set the identity file in the satellite device $ hivemind-client set-identity --key 5a9e580a2773a262cbb23fe9759881ff --password 9b247ca66c7cd2b6388ad49ca504279d --host 0.0.0.0 --port 5678 --siteid test identity saved: /home/miro/.config/hivemind/_identity.json check the created identity file if you like $ cat ~/.config/hivemind/_identity.json { \"password\": \"9b247ca66c7cd2b6388ad49ca504279d\", \"access_key\": \"5a9e580a2773a262cbb23fe9759881ff\", \"site_id\": \"test\", \"default_port\": 5678, \"default_master\": \"ws://0.0.0.0\" } test that a connection is possible using the identity file $ hivemind-client test-identity (...) 2024-05-20 21:22:28.003 - OVOS - hivemind_bus_client.client:__init__:112 - INFO - Session ID: 34d75c93-4e65-4ea9-b5f4-87169dcfda01 (...) == Identity successfully connected to HiveMind! If the identity test passed, then your satellite is paired with the Hive! Audio Pairing via GGWave \ud83d\udea7 This feature is a proof-of-concept / work-in-progress Data over sound for HiveMind hivemind-core and hivemind-voice-sat have hivemind-ggwave support pre-requisites: a device with a browser, eg a phone a hivemind-core device with mic and speaker, eg a mark2 a (unpaired) voice satellite device with mic and speaker, eg a raspberry pi all devices need to be in audible range, they each need to be able to listen to sounds emitted by each other workflow: when launching hivemind-core take note of the provided code, eg HMPSWD:ce357a6b59f6b1f9 copy paste the code and emit it via ggwave (see below) the voice satellite will decode the password, generate an access key and send it back via ggwave master adds a client with key + password, send an ack (containing host) via ggwave satellite devices get the ack then connect to received host manually exchanged string via browser with a talking button The Identity File The identity file is a crucial component in the HiveMind ecosystem, as it stores the necessary credentials and settings for a node (device) to connect and communicate within the HiveMind network. This file ensures that the node can authenticate and maintain secure connections with other nodes. While connection parameters can be set at launch time, this file provides a way to reuse them across the whole OS Contents of the identity file The identity file, typically located at ~/.config/hivemind/_identity.json , contains the following information: Field Description name A human-readable label for the node, which is not guaranteed to be unique. password The password used to generate a session AES key for secure communication within the HiveMind network. access_key A unique access key assigned to the node for identification and authentication. site_id An identifier for the physical location or context in which the node is operating. default_port The default port number used to connect to the HiveMind core. default_master The default host (address) of the HiveMind core that the node connects to. public_key The ASCII-encoded public PGP key used for authenticating the node within the HiveMind network. secret_key The path to the private PGP key file, which uniquely identifies the node and proves its identity. By maintaining these details in the identity file, nodes can securely and efficiently participate in the HiveMind network, facilitating a seamless and secure distributed communication environment. If a node needs to securely communicate or authenticate another (that isn't the master) it can do so via the public key. See the section for intercom messages for more details Groups of devices can also be targeted via their site_id , for example, we can propagate a speak message to announce dinner is ready or broadcast a bus message to order all devices in a certain area equipped with a camera to take a picture. Public Key The Public Key in the identity file is part of a PGP key pair used to uniquely identify the node. This key serves several purposes: Unique Node Identification: The PGP key uniquely identifies this node within the HiveMind network, ensuring that each node can be distinctly recognized. Inter-Node Authentication: Nodes can use the PGP key to authenticate each other, providing a layer of security that ensures only authorized nodes can communicate within the network. Network Independence: The PGP key allows nodes to identify each other regardless of the specific HiveMind core (mind) they are connected to. This means that even if nodes switch Minds, they can still recognize and authenticate each other using their PGP keys. Private Key The Private Key is the only way for a node to read a message encrypted with it's corresponding public key. This file must be kept safe and private at all times! By default, the private key is stored in ~/.config/hivemind/HiveMindComs.asc If you believe your private key has been compromised, or simply want to change keys you can use the hivemind-client reset-pgp command","title":"Pairing"},{"location":"03_pairing/#pairing-devices","text":"You can register clients in a Mind via command line or via audio","title":"Pairing devices"},{"location":"03_pairing/#command-line-pairing","text":"First, you need to register the satellite devices in the HiveMind server $ hivemind-core add-client Credentials added to database! Node ID: 2 Friendly Name: HiveMind-Node-2 Access Key: 5a9e580a2773a262cbb23fe9759881ff Password: 9b247ca66c7cd2b6388ad49ca504279d Encryption Key: 4185240103de0770 WARNING: Encryption Key is deprecated, only use if your client does not support password And then set the identity file in the satellite device $ hivemind-client set-identity --key 5a9e580a2773a262cbb23fe9759881ff --password 9b247ca66c7cd2b6388ad49ca504279d --host 0.0.0.0 --port 5678 --siteid test identity saved: /home/miro/.config/hivemind/_identity.json check the created identity file if you like $ cat ~/.config/hivemind/_identity.json { \"password\": \"9b247ca66c7cd2b6388ad49ca504279d\", \"access_key\": \"5a9e580a2773a262cbb23fe9759881ff\", \"site_id\": \"test\", \"default_port\": 5678, \"default_master\": \"ws://0.0.0.0\" } test that a connection is possible using the identity file $ hivemind-client test-identity (...) 2024-05-20 21:22:28.003 - OVOS - hivemind_bus_client.client:__init__:112 - INFO - Session ID: 34d75c93-4e65-4ea9-b5f4-87169dcfda01 (...) == Identity successfully connected to HiveMind! If the identity test passed, then your satellite is paired with the Hive!","title":"Command Line Pairing"},{"location":"03_pairing/#audio-pairing-via-ggwave","text":"\ud83d\udea7 This feature is a proof-of-concept / work-in-progress Data over sound for HiveMind hivemind-core and hivemind-voice-sat have hivemind-ggwave support pre-requisites: a device with a browser, eg a phone a hivemind-core device with mic and speaker, eg a mark2 a (unpaired) voice satellite device with mic and speaker, eg a raspberry pi all devices need to be in audible range, they each need to be able to listen to sounds emitted by each other workflow: when launching hivemind-core take note of the provided code, eg HMPSWD:ce357a6b59f6b1f9 copy paste the code and emit it via ggwave (see below) the voice satellite will decode the password, generate an access key and send it back via ggwave master adds a client with key + password, send an ack (containing host) via ggwave satellite devices get the ack then connect to received host manually exchanged string via browser with a talking button","title":"Audio Pairing via GGWave"},{"location":"03_pairing/#the-identity-file","text":"The identity file is a crucial component in the HiveMind ecosystem, as it stores the necessary credentials and settings for a node (device) to connect and communicate within the HiveMind network. This file ensures that the node can authenticate and maintain secure connections with other nodes. While connection parameters can be set at launch time, this file provides a way to reuse them across the whole OS","title":"The Identity File"},{"location":"03_pairing/#contents-of-the-identity-file","text":"The identity file, typically located at ~/.config/hivemind/_identity.json , contains the following information: Field Description name A human-readable label for the node, which is not guaranteed to be unique. password The password used to generate a session AES key for secure communication within the HiveMind network. access_key A unique access key assigned to the node for identification and authentication. site_id An identifier for the physical location or context in which the node is operating. default_port The default port number used to connect to the HiveMind core. default_master The default host (address) of the HiveMind core that the node connects to. public_key The ASCII-encoded public PGP key used for authenticating the node within the HiveMind network. secret_key The path to the private PGP key file, which uniquely identifies the node and proves its identity. By maintaining these details in the identity file, nodes can securely and efficiently participate in the HiveMind network, facilitating a seamless and secure distributed communication environment. If a node needs to securely communicate or authenticate another (that isn't the master) it can do so via the public key. See the section for intercom messages for more details Groups of devices can also be targeted via their site_id , for example, we can propagate a speak message to announce dinner is ready or broadcast a bus message to order all devices in a certain area equipped with a camera to take a picture.","title":"Contents of the identity file"},{"location":"03_pairing/#public-key","text":"The Public Key in the identity file is part of a PGP key pair used to uniquely identify the node. This key serves several purposes: Unique Node Identification: The PGP key uniquely identifies this node within the HiveMind network, ensuring that each node can be distinctly recognized. Inter-Node Authentication: Nodes can use the PGP key to authenticate each other, providing a layer of security that ensures only authorized nodes can communicate within the network. Network Independence: The PGP key allows nodes to identify each other regardless of the specific HiveMind core (mind) they are connected to. This means that even if nodes switch Minds, they can still recognize and authenticate each other using their PGP keys.","title":"Public Key"},{"location":"03_pairing/#private-key","text":"The Private Key is the only way for a node to read a message encrypted with it's corresponding public key. This file must be kept safe and private at all times! By default, the private key is stored in ~/.config/hivemind/HiveMindComs.asc If you believe your private key has been compromised, or simply want to change keys you can use the hivemind-client reset-pgp command","title":"Private Key"},{"location":"04_plugins/","text":"HiveMind Plugin Manager The HiveMind Plugin Manager (HPM) is a system for discovering, managing, and loading plugins within the HiveMind ecosystem. It supports various plugin types, including databases, network protocols, agent protocols, and binary data handlers. HPM allows for dynamic integration of these plugins to enhance the functionality of HiveMind agents, offering a flexible and extensible architecture. Features Plugin Discovery : Easily find and load plugins of different types, including: Database Plugins : Supports various database types such as JSON, SQLite, and Redis. Agent Protocol Plugins : Integrates agent protocols like OVOS and Persona, enabling seamless communication between HiveMind agents. Network Protocol Plugins : Enables network protocols such as WebSockets for distributed communication. Binary Data Handler Plugins : Handle binary data communication, like audio data over HiveMind. Plugin Loading : Dynamically load specific plugins by name, type, or from available entry points. Factories for Plugin Instantiation : Factories for creating instances of each plugin type (database, agent protocol, network protocol, binary protocol) based on user configurations. Plugin Types 1. Database Plugins Supports multiple database systems, such as: JSON Database : Stores data in a JSON format. SQLite Database : Uses SQLite for local database storage. Redis Database : Uses Redis for distributed caching and storage. 2. Agent Protocol Plugins Supports communication protocols for agents, such as: OVOS Protocol : For interaction with OVOS-based agents. Persona Protocol : For interaction with the Persona framework. 3. Network Protocol Plugins Enables network communication protocols, such as: WebSocket Protocol : For real-time, bidirectional communication over WebSockets. 4. Binary Data Handler Protocol Plugins Handles communication of binary data types, like audio, using specialized protocols. Installation hivemind-plugin-manager is a dependency of hivemind-core , you typically do not need to install it pip install hivemind-plugin-manager Developers The following example demonstrates how to discover and load plugins, along with creating instances using the provided factories. Discovering Plugins Use the find_plugins function to discover all available plugins for a specific type: from hivemind_plugin_manager import find_plugins, HiveMindPluginTypes # Find all database plugins database_plugins = find_plugins(HiveMindPluginTypes.DATABASE) print(database_plugins) # Find all agent protocol plugins agent_protocol_plugins = find_plugins(HiveMindPluginTypes.AGENT_PROTOCOL) print(agent_protocol_plugins) Creating Plugin Instances Each plugin type has a corresponding factory class that allows for creating plugin instances with the required configuration. Database Plugin Factory from hivemind_plugin_manager import DatabaseFactory # Create an instance of a database plugin db_instance = DatabaseFactory.create(\"hivemind-redis-db-plugin\", password=\"Password1!\", host=\"192.168.1.11\", port=6789) Agent Protocol Factory from hivemind_plugin_manager import AgentProtocolFactory # Create an agent protocol instance agent_protocol_instance = AgentProtocolFactory.create(\"hivemind-ovos-agent-plugin\") Network Protocol Factory from hivemind_plugin_manager import NetworkProtocolFactory # Create a network protocol instance network_protocol_instance = NetworkProtocolFactory.create(\"hivemind-websocket-plugin\") Binary Data Handler Protocol Factory from hivemind_plugin_manager import BinaryDataHandlerProtocolFactory # Create a binary data handler protocol instance binary_data_handler_instance = BinaryDataHandlerProtocolFactory.create(\"hivemind-audio-binary-protocol-plugin\")","title":"Plugins"},{"location":"04_plugins/#hivemind-plugin-manager","text":"The HiveMind Plugin Manager (HPM) is a system for discovering, managing, and loading plugins within the HiveMind ecosystem. It supports various plugin types, including databases, network protocols, agent protocols, and binary data handlers. HPM allows for dynamic integration of these plugins to enhance the functionality of HiveMind agents, offering a flexible and extensible architecture.","title":"HiveMind Plugin Manager"},{"location":"04_plugins/#features","text":"Plugin Discovery : Easily find and load plugins of different types, including: Database Plugins : Supports various database types such as JSON, SQLite, and Redis. Agent Protocol Plugins : Integrates agent protocols like OVOS and Persona, enabling seamless communication between HiveMind agents. Network Protocol Plugins : Enables network protocols such as WebSockets for distributed communication. Binary Data Handler Plugins : Handle binary data communication, like audio data over HiveMind. Plugin Loading : Dynamically load specific plugins by name, type, or from available entry points. Factories for Plugin Instantiation : Factories for creating instances of each plugin type (database, agent protocol, network protocol, binary protocol) based on user configurations.","title":"Features"},{"location":"04_plugins/#plugin-types","text":"","title":"Plugin Types"},{"location":"04_plugins/#1-database-plugins","text":"Supports multiple database systems, such as: JSON Database : Stores data in a JSON format. SQLite Database : Uses SQLite for local database storage. Redis Database : Uses Redis for distributed caching and storage.","title":"1. Database Plugins"},{"location":"04_plugins/#2-agent-protocol-plugins","text":"Supports communication protocols for agents, such as: OVOS Protocol : For interaction with OVOS-based agents. Persona Protocol : For interaction with the Persona framework.","title":"2. Agent Protocol Plugins"},{"location":"04_plugins/#3-network-protocol-plugins","text":"Enables network communication protocols, such as: WebSocket Protocol : For real-time, bidirectional communication over WebSockets.","title":"3. Network Protocol Plugins"},{"location":"04_plugins/#4-binary-data-handler-protocol-plugins","text":"Handles communication of binary data types, like audio, using specialized protocols.","title":"4. Binary Data Handler Protocol Plugins"},{"location":"04_plugins/#installation","text":"hivemind-plugin-manager is a dependency of hivemind-core , you typically do not need to install it pip install hivemind-plugin-manager","title":"Installation"},{"location":"04_plugins/#developers","text":"The following example demonstrates how to discover and load plugins, along with creating instances using the provided factories.","title":"Developers"},{"location":"04_plugins/#discovering-plugins","text":"Use the find_plugins function to discover all available plugins for a specific type: from hivemind_plugin_manager import find_plugins, HiveMindPluginTypes # Find all database plugins database_plugins = find_plugins(HiveMindPluginTypes.DATABASE) print(database_plugins) # Find all agent protocol plugins agent_protocol_plugins = find_plugins(HiveMindPluginTypes.AGENT_PROTOCOL) print(agent_protocol_plugins)","title":"Discovering Plugins"},{"location":"04_plugins/#creating-plugin-instances","text":"Each plugin type has a corresponding factory class that allows for creating plugin instances with the required configuration.","title":"Creating Plugin Instances"},{"location":"04_plugins/#database-plugin-factory","text":"from hivemind_plugin_manager import DatabaseFactory # Create an instance of a database plugin db_instance = DatabaseFactory.create(\"hivemind-redis-db-plugin\", password=\"Password1!\", host=\"192.168.1.11\", port=6789)","title":"Database Plugin Factory"},{"location":"04_plugins/#agent-protocol-factory","text":"from hivemind_plugin_manager import AgentProtocolFactory # Create an agent protocol instance agent_protocol_instance = AgentProtocolFactory.create(\"hivemind-ovos-agent-plugin\")","title":"Agent Protocol Factory"},{"location":"04_plugins/#network-protocol-factory","text":"from hivemind_plugin_manager import NetworkProtocolFactory # Create a network protocol instance network_protocol_instance = NetworkProtocolFactory.create(\"hivemind-websocket-plugin\")","title":"Network Protocol Factory"},{"location":"04_plugins/#binary-data-handler-protocol-factory","text":"from hivemind_plugin_manager import BinaryDataHandlerProtocolFactory # Create a binary data handler protocol instance binary_data_handler_instance = BinaryDataHandlerProtocolFactory.create(\"hivemind-audio-binary-protocol-plugin\")","title":"Binary Data Handler Protocol Factory"},{"location":"04_protocol/","text":"Protocol The HiveMind Protocol enables seamless exchange of information and commands within a distributed network. It defines message types and their handling methods, serving as a transport protocol. While the protocol primarily operates with OpenVoiceOS (OVOS) messages, it is versatile enough to support other payloads. The protocol is categorized into two main roles: Listener Protocol and Client Protocol . Roles and Message Types Listener Protocol Accepts : BUS , SHARED_BUS , PROPAGATE , ESCALATE , INTERCOM Emits : BUS , PROPAGATE , BROADCAST , INTERCOM Client Protocol Accepts : BUS , PROPAGATE , BROADCAST , INTERCOM Emits : BUS , SHARED_BUS , PROPAGATE , ESCALATE , INTERCOM Permissions Permissions are based on a combination of: Access key Allowed Message types Blacklisted Intent types Blacklisted Skill IDs \ud83d\udca1 Use the hivemind-core package to authorize message types or blacklist intents/skills. Example : Allow the \"speak\" message type: $ hivemind-core allow-msg \"speak\" Payload Messages Payload messages encapsulate OpenVoiceOS Message objects, acting as carriers for information or commands. These are the \"cargo\" the HiveMind Protocol transports across the network. Integrations with external AI backends require middleware to process OVOS messages. See hivemind-persona for an example implementation. \u26a0\ufe0f All HiveMind servers are expected to handle natural language queries. At a minimum, the recognizer_loop:utterance OVOS message must be supported. \ud83d\udca1 Use the hivemind-websocket-client package to send a bus message from the command line BUS Message Purpose : Single-hop communication between slaves and masters. Behavior : A master receiving a BUS message checks global whitelists/blacklists and slave permissions. Authorized messages are injected into the master's OVOS-core bus. Direct responses from the master's OVOS-core are forwarded back to the originating slave. Command Line : $ hivemind-client send-mycroft --help Usage: hivemind-client send-mycroft [OPTIONS] send a single mycroft message Options: --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --siteid TEXT location identifier for message.context (default read from identity file) --msg TEXT ovos message type to inject --payload TEXT ovos message.data json --help Show this message and exit. \ud83d\udca1 Valid payloads for OVOS can be found here Visualization : SHARED_BUS Message Purpose : Passive monitoring of a slave device's OVOS-core bus. Direction : Slave \u2192 Master. Behavior : Requires explicit configuration on the slave device. Similar to BUS , but for observation, not processing. \ud83d\udca1 This feature is typically enabled through the HiveMind Skill . Visualization : INTERCOM Message messages may also be encrypted with a node public_key , this ensures intermediate nodes are unable to read the message contents A encrypted message is a regular hive message, but has the type \"INTERCOM\" and payload {\"ciphertext\": \"XXXXXXX\"} Where \"ciphertext\" can only be decoded by the target Node, not by any intermediary these messages are usually the payload of transport messages such as ESCALATE or PROPAGATE payloads. \ud83d\udca1 Intermediate nodes do not know the contents of the message, nor who the recipient is When a message needs to be sent securely, it is encrypted using the recipient node's public PGP key. This ensures that only the intended recipient, who possesses the corresponding private PGP key, can decrypt the message. After encryption, the message is signed with the sender's private PGP key. This provides authentication and integrity, ensuring that the message has not been tampered with and confirming the sender's identity. Upon receiving an encrypted message, the recipient node attempts to decrypt it using its private PGP key. If successful, the message payload is then processed and emitted internally. the target node public key needs to be known beforehand if you want to send secret messages Transport Messages Transport messages encapsulate another HiveMessage object as their payload. These types are particularly relevant for Nested Hives . BROADCAST Message Purpose : Multi-hop communication from master \u2192 slaves. Behavior : Disseminates messages to all connected slaves. Supports target_site_id for directing messages to specific nodes. Example : A master can make all slaves in site_id: \"kitchen\" speak a specific message. \ud83d\udca1 BROADCAST messages are typically sent by skills running in a hivemind server Visualization : ESCALATE Message Purpose : Multi-hop communication from slave \u2192 master. Behavior : Elevates messages up the authority chain for higher-level processing. Visualization : Command Line : $ hivemind-client escalate --help Usage: hivemind-client escalate [OPTIONS] escalate a single mycroft message Options: --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --siteid TEXT location identifier for message.context (default read from identity file) --msg TEXT ovos message type to inject --payload TEXT ovos message.data json --help Show this message and exit. PROPAGATE Message Purpose : Multi-hop communication in both directions (master \u2194 slaves). Behavior : Ensures the message is delivered to all relevant nodes. Visualization : Command Line : $ hivemind-client propagate --help Usage: hivemind-client propagate [OPTIONS] propagate a single mycroft message Options: --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --siteid TEXT location identifier for message.context (default read from identity file) --msg TEXT ovos message type to inject --payload TEXT ovos message.data json --help Show this message and exit. Protocol Features Feature Protocol v0 Protocol v1 JSON serialization \u2705 \u2705 Binary serialization \u274c \u2705 Pre-shared AES key \u2705 \u2705 Password handshake \u274c \u2705 PGP handshake \u274c \u2705 Zlib compression \u274c \u2705 \u26a0\ufe0f Protocol v0 is deprecated ! However some clients (e.g., HiveMind-Js) may not yet support Protocol Version 1.","title":"Transport"},{"location":"04_protocol/#protocol","text":"The HiveMind Protocol enables seamless exchange of information and commands within a distributed network. It defines message types and their handling methods, serving as a transport protocol. While the protocol primarily operates with OpenVoiceOS (OVOS) messages, it is versatile enough to support other payloads. The protocol is categorized into two main roles: Listener Protocol and Client Protocol .","title":"Protocol"},{"location":"04_protocol/#roles-and-message-types","text":"","title":"Roles and Message Types"},{"location":"04_protocol/#listener-protocol","text":"Accepts : BUS , SHARED_BUS , PROPAGATE , ESCALATE , INTERCOM Emits : BUS , PROPAGATE , BROADCAST , INTERCOM","title":"Listener Protocol"},{"location":"04_protocol/#client-protocol","text":"Accepts : BUS , PROPAGATE , BROADCAST , INTERCOM Emits : BUS , SHARED_BUS , PROPAGATE , ESCALATE , INTERCOM","title":"Client Protocol"},{"location":"04_protocol/#permissions","text":"Permissions are based on a combination of: Access key Allowed Message types Blacklisted Intent types Blacklisted Skill IDs \ud83d\udca1 Use the hivemind-core package to authorize message types or blacklist intents/skills. Example : Allow the \"speak\" message type: $ hivemind-core allow-msg \"speak\"","title":"Permissions"},{"location":"04_protocol/#payload-messages","text":"Payload messages encapsulate OpenVoiceOS Message objects, acting as carriers for information or commands. These are the \"cargo\" the HiveMind Protocol transports across the network. Integrations with external AI backends require middleware to process OVOS messages. See hivemind-persona for an example implementation. \u26a0\ufe0f All HiveMind servers are expected to handle natural language queries. At a minimum, the recognizer_loop:utterance OVOS message must be supported. \ud83d\udca1 Use the hivemind-websocket-client package to send a bus message from the command line","title":"Payload Messages"},{"location":"04_protocol/#bus-message","text":"Purpose : Single-hop communication between slaves and masters. Behavior : A master receiving a BUS message checks global whitelists/blacklists and slave permissions. Authorized messages are injected into the master's OVOS-core bus. Direct responses from the master's OVOS-core are forwarded back to the originating slave. Command Line : $ hivemind-client send-mycroft --help Usage: hivemind-client send-mycroft [OPTIONS] send a single mycroft message Options: --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --siteid TEXT location identifier for message.context (default read from identity file) --msg TEXT ovos message type to inject --payload TEXT ovos message.data json --help Show this message and exit. \ud83d\udca1 Valid payloads for OVOS can be found here Visualization :","title":"BUS Message"},{"location":"04_protocol/#shared_bus-message","text":"Purpose : Passive monitoring of a slave device's OVOS-core bus. Direction : Slave \u2192 Master. Behavior : Requires explicit configuration on the slave device. Similar to BUS , but for observation, not processing. \ud83d\udca1 This feature is typically enabled through the HiveMind Skill . Visualization :","title":"SHARED_BUS Message"},{"location":"04_protocol/#intercom-message","text":"messages may also be encrypted with a node public_key , this ensures intermediate nodes are unable to read the message contents A encrypted message is a regular hive message, but has the type \"INTERCOM\" and payload {\"ciphertext\": \"XXXXXXX\"} Where \"ciphertext\" can only be decoded by the target Node, not by any intermediary these messages are usually the payload of transport messages such as ESCALATE or PROPAGATE payloads. \ud83d\udca1 Intermediate nodes do not know the contents of the message, nor who the recipient is When a message needs to be sent securely, it is encrypted using the recipient node's public PGP key. This ensures that only the intended recipient, who possesses the corresponding private PGP key, can decrypt the message. After encryption, the message is signed with the sender's private PGP key. This provides authentication and integrity, ensuring that the message has not been tampered with and confirming the sender's identity. Upon receiving an encrypted message, the recipient node attempts to decrypt it using its private PGP key. If successful, the message payload is then processed and emitted internally. the target node public key needs to be known beforehand if you want to send secret messages","title":"INTERCOM Message"},{"location":"04_protocol/#transport-messages","text":"Transport messages encapsulate another HiveMessage object as their payload. These types are particularly relevant for Nested Hives .","title":"Transport Messages"},{"location":"04_protocol/#broadcast-message","text":"Purpose : Multi-hop communication from master \u2192 slaves. Behavior : Disseminates messages to all connected slaves. Supports target_site_id for directing messages to specific nodes. Example : A master can make all slaves in site_id: \"kitchen\" speak a specific message. \ud83d\udca1 BROADCAST messages are typically sent by skills running in a hivemind server Visualization :","title":"BROADCAST Message"},{"location":"04_protocol/#escalate-message","text":"Purpose : Multi-hop communication from slave \u2192 master. Behavior : Elevates messages up the authority chain for higher-level processing. Visualization : Command Line : $ hivemind-client escalate --help Usage: hivemind-client escalate [OPTIONS] escalate a single mycroft message Options: --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --siteid TEXT location identifier for message.context (default read from identity file) --msg TEXT ovos message type to inject --payload TEXT ovos message.data json --help Show this message and exit.","title":"ESCALATE Message"},{"location":"04_protocol/#propagate-message","text":"Purpose : Multi-hop communication in both directions (master \u2194 slaves). Behavior : Ensures the message is delivered to all relevant nodes. Visualization : Command Line : $ hivemind-client propagate --help Usage: hivemind-client propagate [OPTIONS] propagate a single mycroft message Options: --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --siteid TEXT location identifier for message.context (default read from identity file) --msg TEXT ovos message type to inject --payload TEXT ovos message.data json --help Show this message and exit.","title":"PROPAGATE Message"},{"location":"04_protocol/#protocol-features","text":"Feature Protocol v0 Protocol v1 JSON serialization \u2705 \u2705 Binary serialization \u274c \u2705 Pre-shared AES key \u2705 \u2705 Password handshake \u274c \u2705 PGP handshake \u274c \u2705 Zlib compression \u274c \u2705 \u26a0\ufe0f Protocol v0 is deprecated ! However some clients (e.g., HiveMind-Js) may not yet support Protocol Version 1.","title":"Protocol Features"},{"location":"05_presence/","text":"Auto Discovery Hivemind-presence is an utility to enable auto discovery of HiveMind nodes in your network Command line usage $ hivemind-presence --help Usage: hivemind-presence [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: announce Advertise node in the local network scan scan for hivemind nodes in the local network Announce your HiveMind node in your lan via UpnP and Zeroconf $ hivemind-presence announce --help Usage: hivemind-presence announce [OPTIONS] Advertise node in the local network Options: --port INTEGER HiveMind port number (default: 5678) --name TEXT friendly device name (default: HiveMind-Node) --service-type TEXT HiveMind service type (default: HiveMind-websocket) --zeroconf BOOLEAN advertise via zeroconf (default: True) --upnp BOOLEAN advertise via UPNP (default: False) --help Show this message and exit. Scan for HiveMind nodes in your lan via UpnP and Zeroconf $ hivemind-presence scan --help Usage: hivemind-presence scan [OPTIONS] scan for hivemind nodes in the local network Options: --zeroconf BOOLEAN scan via zeroconf (default: True) --upnp BOOLEAN scan via UPNP (default: False) --service-type TEXT HiveMind service type (default: HiveMind-websocket) --help Show this message and exit. $ hivemind-presence scan HiveMind Nodes \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Friendly Name \u2503 Host \u2503 Port \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 living_room \u2502 192.168.1.9 \u2502 5678 \u2502 \u2502 kitchen \u2502 192.168.1.13 \u2502 5678 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Auto Discovery"},{"location":"05_presence/#auto-discovery","text":"Hivemind-presence is an utility to enable auto discovery of HiveMind nodes in your network","title":"Auto Discovery"},{"location":"05_presence/#command-line-usage","text":"$ hivemind-presence --help Usage: hivemind-presence [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: announce Advertise node in the local network scan scan for hivemind nodes in the local network Announce your HiveMind node in your lan via UpnP and Zeroconf $ hivemind-presence announce --help Usage: hivemind-presence announce [OPTIONS] Advertise node in the local network Options: --port INTEGER HiveMind port number (default: 5678) --name TEXT friendly device name (default: HiveMind-Node) --service-type TEXT HiveMind service type (default: HiveMind-websocket) --zeroconf BOOLEAN advertise via zeroconf (default: True) --upnp BOOLEAN advertise via UPNP (default: False) --help Show this message and exit. Scan for HiveMind nodes in your lan via UpnP and Zeroconf $ hivemind-presence scan --help Usage: hivemind-presence scan [OPTIONS] scan for hivemind nodes in the local network Options: --zeroconf BOOLEAN scan via zeroconf (default: True) --upnp BOOLEAN scan via UPNP (default: False) --service-type TEXT HiveMind service type (default: HiveMind-websocket) --help Show this message and exit. $ hivemind-presence scan HiveMind Nodes \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Friendly Name \u2503 Host \u2503 Port \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 living_room \u2502 192.168.1.9 \u2502 5678 \u2502 \u2502 kitchen \u2502 192.168.1.13 \u2502 5678 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Command line usage"},{"location":"06_skills_server/","text":"OpenVoiceOS Skills Server Hivemind-core is the reference integrations with OpenVoiceOS \ud83d\udca1 For a minimal install you only need hivemind-core , ovos-core and ovos-messagebus Install pip install hivemind-core Usage Everything is done via the hivemind-core command, see pairing for more info $ hivemind-core --help Usage: hivemind-core [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: add-client add credentials for a client allow-msg allow message types sent from a client delete-client remove credentials for a client list-clients list clients and credentials listen start listening for HiveMind connections $ hivemind-core listen --help Usage: hivemind-core listen [OPTIONS] start listening for HiveMind connections Options: --host TEXT HiveMind host --port INTEGER HiveMind port number --ssl BOOLEAN use wss:// --cert_dir TEXT HiveMind SSL certificate directory --cert_name TEXT HiveMind SSL certificate file name --db-backend [redis|json|sqlite] Select the database backend to use. Options: redis, sqlite, json. --db-name TEXT [json/sqlite] The name for the database file. ~/.cache/hivemind-core/{name} --db-folder TEXT [json/sqlite] The subfolder where database files are stored. ~/.cache/{db_folder}} --redis-host TEXT [redis] Host for Redis. Default is localhost. --redis-port INTEGER [redis] Port for Redis. Default is 6379. --redis-password TEXT [redis] Password for Redis. Default None --help Show this message and exit. Why HiveMind? HiveMind offers a decentralized solution for OVOS, with features such as secure communication, device integration, and protocol transparency. Here's what it brings to the table: HiveMind as an OVOS Add-on Start with OVOS by installing ovos-core , or use a Mycroft device . Then, run hivemind-core to enable HiveMind functionality. This transforms your OVOS node into a connected system with the \"brain\" of HiveMind. Decentralizing OVOS-Core With HiveMind, thin clients like the voice satellite can connect without running full OVOS software. This allows for multiple access points (e.g., microphones across your home) while keeping the core in a central location. Encrypted Communication HiveMind supports SSL-encrypted communication, eliminating the need for manual certificate management. It auto-generates self-signed certificates for secure, encrypted connections between devices. MessageBus Authentication & Security HiveMind enforces authentication for the message bus, ensuring only authorized clients can connect. This enhances privacy and prevents unauthorized access, unlike traditional setups where the message bus is open. Exposing OVOS to the Web Safely HiveMind can expose your OVOS instance securely over the web. By using the Flask chatroom template , you can interact with OVOS remotely while maintaining privacy and security. Protocol for Integration HiveMind allows integration with external platforms like Android, Mattermost, or Twitch. Whether you want to turn OVOS into a chatbot or integrate it with other services, HiveMind provides the protocol for seamless interaction. Key Features & Setup HiveMind in Action: Devices Connecting: Install the HiveMind CLI and register with your OVOS node to connect devices across your network. Decentralization: Use lightweight devices like Raspberry Pi with HiveMind to extend OVOS functionality across rooms. Encryption & Authentication: Safely transmit data over SSL, with built-in encryption and message authentication. Web Exposure: Use HiveMind\u2019s secure web interface to interact with OVOS remotely. Chat Integrations: Install bridges like the HackChat or Mattermost bridges to bring OVOS to chat platforms. By leveraging HiveMind's features, you can transform OVOS into a flexible, decentralized, and secure platform, capable of handling a wide variety of use cases and integrations.","title":"Skills Server"},{"location":"06_skills_server/#openvoiceos-skills-server","text":"Hivemind-core is the reference integrations with OpenVoiceOS \ud83d\udca1 For a minimal install you only need hivemind-core , ovos-core and ovos-messagebus","title":"OpenVoiceOS Skills Server"},{"location":"06_skills_server/#install","text":"pip install hivemind-core","title":"Install"},{"location":"06_skills_server/#usage","text":"Everything is done via the hivemind-core command, see pairing for more info $ hivemind-core --help Usage: hivemind-core [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: add-client add credentials for a client allow-msg allow message types sent from a client delete-client remove credentials for a client list-clients list clients and credentials listen start listening for HiveMind connections $ hivemind-core listen --help Usage: hivemind-core listen [OPTIONS] start listening for HiveMind connections Options: --host TEXT HiveMind host --port INTEGER HiveMind port number --ssl BOOLEAN use wss:// --cert_dir TEXT HiveMind SSL certificate directory --cert_name TEXT HiveMind SSL certificate file name --db-backend [redis|json|sqlite] Select the database backend to use. Options: redis, sqlite, json. --db-name TEXT [json/sqlite] The name for the database file. ~/.cache/hivemind-core/{name} --db-folder TEXT [json/sqlite] The subfolder where database files are stored. ~/.cache/{db_folder}} --redis-host TEXT [redis] Host for Redis. Default is localhost. --redis-port INTEGER [redis] Port for Redis. Default is 6379. --redis-password TEXT [redis] Password for Redis. Default None --help Show this message and exit.","title":"Usage"},{"location":"06_skills_server/#why-hivemind","text":"HiveMind offers a decentralized solution for OVOS, with features such as secure communication, device integration, and protocol transparency. Here's what it brings to the table: HiveMind as an OVOS Add-on Start with OVOS by installing ovos-core , or use a Mycroft device . Then, run hivemind-core to enable HiveMind functionality. This transforms your OVOS node into a connected system with the \"brain\" of HiveMind. Decentralizing OVOS-Core With HiveMind, thin clients like the voice satellite can connect without running full OVOS software. This allows for multiple access points (e.g., microphones across your home) while keeping the core in a central location. Encrypted Communication HiveMind supports SSL-encrypted communication, eliminating the need for manual certificate management. It auto-generates self-signed certificates for secure, encrypted connections between devices. MessageBus Authentication & Security HiveMind enforces authentication for the message bus, ensuring only authorized clients can connect. This enhances privacy and prevents unauthorized access, unlike traditional setups where the message bus is open. Exposing OVOS to the Web Safely HiveMind can expose your OVOS instance securely over the web. By using the Flask chatroom template , you can interact with OVOS remotely while maintaining privacy and security. Protocol for Integration HiveMind allows integration with external platforms like Android, Mattermost, or Twitch. Whether you want to turn OVOS into a chatbot or integrate it with other services, HiveMind provides the protocol for seamless interaction.","title":"Why HiveMind?"},{"location":"06_skills_server/#key-features-setup","text":"HiveMind in Action: Devices Connecting: Install the HiveMind CLI and register with your OVOS node to connect devices across your network. Decentralization: Use lightweight devices like Raspberry Pi with HiveMind to extend OVOS functionality across rooms. Encryption & Authentication: Safely transmit data over SSL, with built-in encryption and message authentication. Web Exposure: Use HiveMind\u2019s secure web interface to interact with OVOS remotely. Chat Integrations: Install bridges like the HackChat or Mattermost bridges to bring OVOS to chat platforms. By leveraging HiveMind's features, you can transform OVOS into a flexible, decentralized, and secure platform, capable of handling a wide variety of use cases and integrations.","title":"Key Features &amp; Setup"},{"location":"06_sound_server/","text":"HiveMind Sound Server hivemind-listener extends hivemind-core and integrates with ovos-simple-listener , enabling audio-based communication with advanced features for secure, distributed voice assistant functionality . \ud83d\udca1 If you are running a home server this is the best option, you only need to install hivemind-listener , ovos-core and ovos-messagebus . \u26a0\ufe0f If running on a device that is also a full OVOS assistant by itself you should use hivemind-core instead Key Features of HiveMind Listener Audio Stream Handling : Accepts encrypted binary audio streams, performing WakeWord detection , Voice Activity Detection (VAD) , Speech-to-Text (STT) , and Text-to-Speech (TTS) directly on the hivemind-listener instance. (Lightweight clients like hivemind-mic-satellite only run a microphone and VAD plugin.) STT Service : Provides STT via the hivemind-websocket-client , accepting Base64-encoded audio inputs. TTS Service : Provides TTS via the hivemind-websocket-client , returning Base64-encoded audio outputs. Secure Plugin Access : Running TTS/STT via HiveMind Listener requires an access key, offering fine-grained access control compared to non-authenticated server plugins. Usage Install HiveMind Listener : pip install hivemind-listener Start the HiveMind Listener : $ hivemind-listener --help Usage: hivemind-listener [OPTIONS] Run the HiveMind Listener with configurable plugins. If a plugin is not specified, the defaults from mycroft.conf will be used. mycroft.conf will be loaded as usual for plugin settings. Options: --wakeword TEXT Specify the wake word for the listener. Default is 'hey_mycroft'. --stt-plugin TEXT Specify the STT plugin to use. --tts-plugin TEXT Specify the TTS plugin to use. --vad-plugin TEXT Specify the VAD plugin to use. --dialog-transformers TEXT dialog transformer plugins to load. Installed plugins: None --utterance-transformers TEXT utterance transformer plugins to load. Installed plugins: ['ovos-utterance-plugin-cancel'] --metadata-transformers TEXT metadata transformer plugins to load. Installed plugins: None --ovos_bus_address TEXT Open Voice OS bus address --ovos_bus_port INTEGER Open Voice OS bus port number --host TEXT HiveMind host --port INTEGER HiveMind port number --ssl BOOLEAN use wss:// --cert_dir TEXT HiveMind SSL certificate directory --cert_name TEXT HiveMind SSL certificate file name --db-backend [redis|json|sqlite] Select the database backend to use. Options: redis, sqlite, json. --db-name TEXT [json/sqlite] The name for the database file. ~/.cache/hivemind-core/{name} --db-folder TEXT [json/sqlite] The subfolder where database files are stored. ~/.cache/{db_folder}} --redis-host TEXT [redis] Host for Redis. Default is localhost. --redis-port INTEGER [redis] Port for Redis. Default is 6379. --redis-password TEXT [redis] Password for Redis. Default None --help Show this message and exit. This command will run the HiveMind Listener, with configurable plugins for wakeword detection, STT, TTS, and VAD, as well as access control via SSL. Example Use Cases Microphone Satellite : Use hivemind-mic-satellite to stream raw audio to the hivemind-listener . Microphones handle audio capture and VAD, while the Listener manages WakeWord, STT, and TTS processing. Authenticated STT/TTS Services : Connect clients securely using access keys for transcribing or synthesizing audio via the HiveMind Listener, ensuring robust access control.","title":"Sound Server"},{"location":"06_sound_server/#hivemind-sound-server","text":"hivemind-listener extends hivemind-core and integrates with ovos-simple-listener , enabling audio-based communication with advanced features for secure, distributed voice assistant functionality . \ud83d\udca1 If you are running a home server this is the best option, you only need to install hivemind-listener , ovos-core and ovos-messagebus . \u26a0\ufe0f If running on a device that is also a full OVOS assistant by itself you should use hivemind-core instead","title":"HiveMind Sound Server"},{"location":"06_sound_server/#key-features-of-hivemind-listener","text":"Audio Stream Handling : Accepts encrypted binary audio streams, performing WakeWord detection , Voice Activity Detection (VAD) , Speech-to-Text (STT) , and Text-to-Speech (TTS) directly on the hivemind-listener instance. (Lightweight clients like hivemind-mic-satellite only run a microphone and VAD plugin.) STT Service : Provides STT via the hivemind-websocket-client , accepting Base64-encoded audio inputs. TTS Service : Provides TTS via the hivemind-websocket-client , returning Base64-encoded audio outputs. Secure Plugin Access : Running TTS/STT via HiveMind Listener requires an access key, offering fine-grained access control compared to non-authenticated server plugins.","title":"Key Features of HiveMind Listener"},{"location":"06_sound_server/#usage","text":"Install HiveMind Listener : pip install hivemind-listener Start the HiveMind Listener : $ hivemind-listener --help Usage: hivemind-listener [OPTIONS] Run the HiveMind Listener with configurable plugins. If a plugin is not specified, the defaults from mycroft.conf will be used. mycroft.conf will be loaded as usual for plugin settings. Options: --wakeword TEXT Specify the wake word for the listener. Default is 'hey_mycroft'. --stt-plugin TEXT Specify the STT plugin to use. --tts-plugin TEXT Specify the TTS plugin to use. --vad-plugin TEXT Specify the VAD plugin to use. --dialog-transformers TEXT dialog transformer plugins to load. Installed plugins: None --utterance-transformers TEXT utterance transformer plugins to load. Installed plugins: ['ovos-utterance-plugin-cancel'] --metadata-transformers TEXT metadata transformer plugins to load. Installed plugins: None --ovos_bus_address TEXT Open Voice OS bus address --ovos_bus_port INTEGER Open Voice OS bus port number --host TEXT HiveMind host --port INTEGER HiveMind port number --ssl BOOLEAN use wss:// --cert_dir TEXT HiveMind SSL certificate directory --cert_name TEXT HiveMind SSL certificate file name --db-backend [redis|json|sqlite] Select the database backend to use. Options: redis, sqlite, json. --db-name TEXT [json/sqlite] The name for the database file. ~/.cache/hivemind-core/{name} --db-folder TEXT [json/sqlite] The subfolder where database files are stored. ~/.cache/{db_folder}} --redis-host TEXT [redis] Host for Redis. Default is localhost. --redis-port INTEGER [redis] Port for Redis. Default is 6379. --redis-password TEXT [redis] Password for Redis. Default None --help Show this message and exit. This command will run the HiveMind Listener, with configurable plugins for wakeword detection, STT, TTS, and VAD, as well as access control via SSL.","title":"Usage"},{"location":"06_sound_server/#example-use-cases","text":"Microphone Satellite : Use hivemind-mic-satellite to stream raw audio to the hivemind-listener . Microphones handle audio capture and VAD, while the Listener manages WakeWord, STT, and TTS processing. Authenticated STT/TTS Services : Connect clients securely using access keys for transcribing or synthesizing audio via the HiveMind Listener, ensuring robust access control.","title":"Example Use Cases"},{"location":"07_homeassistant/","text":"HiveMind Integration for Home Assistant This is a manual install Home Assistant integration for connecting to an OpenVoiceOS instance via HiveMind It allows Home Assistant to directly control and interact with a HiveMind device at a system level, not just sending voice commands, but also manipulating services like audio playback, volume, and system power. Related Projects: hivemind-homeassistant (this integration) allows HiveMind to show up as a device in Home Assistant hivemind-player-protocol turn any device into a standalone HiveMind OCP player ovos-skill-music-assistant allows OVOS to search media in MA sources ovos-media-plugin-mass allows OVOS to control MA players Manual Installation Copy the hivemind folder into your Home Assistant custom_components directory: mkdir -p /config/custom_components cp -r custom_components/hivemind /config/custom_components/ Restart Home Assistant. Add the HiveMind integration via the Home Assistant UI: Settings \u2192 Devices & Services \u2192 Add Integration \u2192 HiveMind Home Assistant Setup Once a HiveMind device is added to HomeAssistant you will have several entities available controls media player notify status sensors Music Assistant Permissions Required Since this integration does more than just voice queries , it requires low-level permissions to inject and control bus messages directly. The client connecting to HiveMind must have admin privileges and permission to access the following message types: ovos-core mycroft.stop mycroft.skills.is_alive mycroft.skills.is_ready ovos-dinkum-listener mycroft.voice.is_alive mycroft.voice.is_ready mycroft.mic.listen mycroft.mic.mute mycroft.mic.unmute mycroft.mic.get_status recognizer_loop:sleep recognizer_loop:wake_up recognizer_loop:state.get recognizer_loop:state.set ovos-gui mycroft.gui_service.is_alive mycroft.gui_service.is_ready ovos-audio speak mycroft.audio.is_alive mycroft.audio.is_ready mycroft.audio.speak.status OCP (OpenVoiceOS Common Play) ovos.common_play.player.status ovos.common_play.track_info ovos.common_play.get_track_length ovos.common_play.get_track_position ovos.common_play.playlist.queue ovos.common_play.resume ovos.common_play.pause ovos.common_play.stop ovos.common_play.previous ovos.common_play.next ovos.common_play.set_track_position ovos.common_play.playlist.clear ovos.common_play.shuffle.set ovos.common_play.shuffle.unset ovos.common_play.repeat.set ovos.common_play.repeat.unset ovos.common_play.repeat.one Audio Service (only if enabled manually \u2014 for systems without the OCP Audio Plugin) mycroft.audio.service.play mycroft.audio.service.resume mycroft.audio.service.pause mycroft.audio.service.stop mycroft.audio.service.prev mycroft.audio.service.next mycroft.audio.service.set_track_position PHAL mycroft.phal.is_alive mycroft.phal.is_ready ovos-phal-plugin-alsa mycroft.volume.get mycroft.volume.increase mycroft.volume.decrease mycroft.volume.mute mycroft.volume.unmute ovos-phal-plugin-system system.reboot system.shutdown system.mycroft.service.restart system.ssh.status ovos-phal-plugin-camera ( work in progress ) ovos.phal.camera.ping ovos.phal.camera.get ovos.phal.camera.open ovos.phal.camera.close","title":"Home Assistant"},{"location":"07_homeassistant/#hivemind-integration-for-home-assistant","text":"This is a manual install Home Assistant integration for connecting to an OpenVoiceOS instance via HiveMind It allows Home Assistant to directly control and interact with a HiveMind device at a system level, not just sending voice commands, but also manipulating services like audio playback, volume, and system power.","title":"HiveMind Integration for Home Assistant"},{"location":"07_homeassistant/#related-projects","text":"hivemind-homeassistant (this integration) allows HiveMind to show up as a device in Home Assistant hivemind-player-protocol turn any device into a standalone HiveMind OCP player ovos-skill-music-assistant allows OVOS to search media in MA sources ovos-media-plugin-mass allows OVOS to control MA players","title":"Related Projects:"},{"location":"07_homeassistant/#manual-installation","text":"Copy the hivemind folder into your Home Assistant custom_components directory: mkdir -p /config/custom_components cp -r custom_components/hivemind /config/custom_components/ Restart Home Assistant. Add the HiveMind integration via the Home Assistant UI: Settings \u2192 Devices & Services \u2192 Add Integration \u2192 HiveMind","title":"Manual Installation"},{"location":"07_homeassistant/#home-assistant-setup","text":"Once a HiveMind device is added to HomeAssistant you will have several entities available controls media player notify status sensors","title":"Home Assistant Setup"},{"location":"07_homeassistant/#music-assistant","text":"","title":"Music Assistant"},{"location":"07_homeassistant/#permissions-required","text":"Since this integration does more than just voice queries , it requires low-level permissions to inject and control bus messages directly. The client connecting to HiveMind must have admin privileges and permission to access the following message types:","title":"Permissions Required"},{"location":"07_homeassistant/#ovos-core","text":"mycroft.stop mycroft.skills.is_alive mycroft.skills.is_ready","title":"ovos-core"},{"location":"07_homeassistant/#ovos-dinkum-listener","text":"mycroft.voice.is_alive mycroft.voice.is_ready mycroft.mic.listen mycroft.mic.mute mycroft.mic.unmute mycroft.mic.get_status recognizer_loop:sleep recognizer_loop:wake_up recognizer_loop:state.get recognizer_loop:state.set","title":"ovos-dinkum-listener"},{"location":"07_homeassistant/#ovos-gui","text":"mycroft.gui_service.is_alive mycroft.gui_service.is_ready","title":"ovos-gui"},{"location":"07_homeassistant/#ovos-audio","text":"speak mycroft.audio.is_alive mycroft.audio.is_ready mycroft.audio.speak.status","title":"ovos-audio"},{"location":"07_homeassistant/#ocp-openvoiceos-common-play","text":"ovos.common_play.player.status ovos.common_play.track_info ovos.common_play.get_track_length ovos.common_play.get_track_position ovos.common_play.playlist.queue ovos.common_play.resume ovos.common_play.pause ovos.common_play.stop ovos.common_play.previous ovos.common_play.next ovos.common_play.set_track_position ovos.common_play.playlist.clear ovos.common_play.shuffle.set ovos.common_play.shuffle.unset ovos.common_play.repeat.set ovos.common_play.repeat.unset ovos.common_play.repeat.one","title":"OCP (OpenVoiceOS Common Play)"},{"location":"07_homeassistant/#audio-service","text":"(only if enabled manually \u2014 for systems without the OCP Audio Plugin) mycroft.audio.service.play mycroft.audio.service.resume mycroft.audio.service.pause mycroft.audio.service.stop mycroft.audio.service.prev mycroft.audio.service.next mycroft.audio.service.set_track_position","title":"Audio Service"},{"location":"07_homeassistant/#phal","text":"mycroft.phal.is_alive mycroft.phal.is_ready","title":"PHAL"},{"location":"07_homeassistant/#ovos-phal-plugin-alsa","text":"mycroft.volume.get mycroft.volume.increase mycroft.volume.decrease mycroft.volume.mute mycroft.volume.unmute","title":"ovos-phal-plugin-alsa"},{"location":"07_homeassistant/#ovos-phal-plugin-system","text":"system.reboot system.shutdown system.mycroft.service.restart system.ssh.status","title":"ovos-phal-plugin-system"},{"location":"07_homeassistant/#ovos-phal-plugin-camera","text":"( work in progress ) ovos.phal.camera.ping ovos.phal.camera.get ovos.phal.camera.open ovos.phal.camera.close","title":"ovos-phal-plugin-camera"},{"location":"07_micsat/","text":"HiveMind Microphone Satellite OpenVoiceOS Microphone Satellite, connect to HiveMind Listener A super lightweight version of voice-satellite , only Microphone and VAD plugins runs on the mic-satellite, voice activity is streamed to hivemind-listener and all the processing happens there Server requirements \u26a0\ufe0f hivemind-listener is required server side, the default hivemind-core does not provide STT and TTS capabilities. Install Install with pip $ pip install hivemind-mic-satellite Configuration Voice relay is built on top of ovos-plugin-manager , it uses the same OpenVoiceOS configuration ~/.config/mycroft/mycroft.conf Supported plugins: Plugin Type Description Required Link Microphone Captures voice input Yes Microphone VAD Voice Activity Detection Yes VAD PHAL Platform/Hardware Abstraction Layer No PHAL G2P Generate visemes (mouth movements), eg. for Mk1 No G2P Media Playback Plugins Enables media playback (e.g., \"play Metallica\") No Media Playback Plugins OCP Plugins Provides playback support for URLs (e.g., YouTube) No OCP Plugins The regular voice satellite is built on top of ovos-dinkum-listener and is full featured supporting all plugins This repo needs less resources but it is also missing some features STT plugin (runs on server) TTS plugin (runs on server) WakeWord plugin (runs on server) Continuous Listening Hybrid Listening Recording Mode Sleep Mode Multiple WakeWords Audio Transformers plugins Dialog Transformers plugins (TODO - support in the future)","title":"Mic Satellite"},{"location":"07_micsat/#hivemind-microphone-satellite","text":"OpenVoiceOS Microphone Satellite, connect to HiveMind Listener A super lightweight version of voice-satellite , only Microphone and VAD plugins runs on the mic-satellite, voice activity is streamed to hivemind-listener and all the processing happens there","title":"HiveMind Microphone Satellite"},{"location":"07_micsat/#server-requirements","text":"\u26a0\ufe0f hivemind-listener is required server side, the default hivemind-core does not provide STT and TTS capabilities.","title":"Server requirements"},{"location":"07_micsat/#install","text":"Install with pip $ pip install hivemind-mic-satellite","title":"Install"},{"location":"07_micsat/#configuration","text":"Voice relay is built on top of ovos-plugin-manager , it uses the same OpenVoiceOS configuration ~/.config/mycroft/mycroft.conf Supported plugins: Plugin Type Description Required Link Microphone Captures voice input Yes Microphone VAD Voice Activity Detection Yes VAD PHAL Platform/Hardware Abstraction Layer No PHAL G2P Generate visemes (mouth movements), eg. for Mk1 No G2P Media Playback Plugins Enables media playback (e.g., \"play Metallica\") No Media Playback Plugins OCP Plugins Provides playback support for URLs (e.g., YouTube) No OCP Plugins The regular voice satellite is built on top of ovos-dinkum-listener and is full featured supporting all plugins This repo needs less resources but it is also missing some features STT plugin (runs on server) TTS plugin (runs on server) WakeWord plugin (runs on server) Continuous Listening Hybrid Listening Recording Mode Sleep Mode Multiple WakeWords Audio Transformers plugins Dialog Transformers plugins (TODO - support in the future)","title":"Configuration"},{"location":"07_voice_relay/","text":"HiveMind Voice Relay OpenVoiceOS Relay, connect to HiveMind A lightweight version of voice-satellite , but STT and TTS are sent to HiveMind instead of handled on device Server requirements \u26a0\ufe0f hivemind-listener is required server side, the default hivemind-core does not provide STT and TTS capabilities. Alternatively run hivemind-core together with ovos-audio and ovos-dinkum-listener The regular voice satellite is built on top of ovos-dinkum-listener and is full featured supporting all plugins The voice relay is built on top of ovos-simple-listener , while it needs less resources it is also missing some features STT plugin TTS plugin Audio Transformers plugins Continuous Listening Hybrid Listening Recording Mode Sleep Mode Multiple WakeWords If you need an even lighter implementation, consider hivemind-mic-satellite to also offload wake word to the server Install Install with pip $ pip install HiveMind-voice-relay Usage Usage: hivemind-voice-relay [OPTIONS] connect to HiveMind Options: --host TEXT hivemind host --key TEXT Access Key --password TEXT Password for key derivation --port INTEGER HiveMind port number --selfsigned accept self signed certificates --help Show this message and exit. Configuration Voice relay is built on top of ovos-simple-listener and ovos-audio , it uses the default OpenVoiceOS configuration ~/.config/mycroft/mycroft.conf Supported plugin types: Plugin Type Description Required Link Microphone Captures voice input Yes Microphone VAD Voice Activity Detection Yes VAD WakeWord Detects wake words for interaction Yes WakeWord G2P grapheme-to-phoneme (G2P), used to simulate mouth movements No G2P Media Playback Plugins Enables media playback (e.g., \"play Metallica\") No Media Playback Plugins OCP Plugins Provides playback support for URLs (e.g., YouTube) No OCP Plugins PHAL Provides platform-specific support (e.g., Mark 1) No PHAL","title":"Voice Relay"},{"location":"07_voice_relay/#hivemind-voice-relay","text":"OpenVoiceOS Relay, connect to HiveMind A lightweight version of voice-satellite , but STT and TTS are sent to HiveMind instead of handled on device","title":"HiveMind Voice Relay"},{"location":"07_voice_relay/#server-requirements","text":"\u26a0\ufe0f hivemind-listener is required server side, the default hivemind-core does not provide STT and TTS capabilities. Alternatively run hivemind-core together with ovos-audio and ovos-dinkum-listener The regular voice satellite is built on top of ovos-dinkum-listener and is full featured supporting all plugins The voice relay is built on top of ovos-simple-listener , while it needs less resources it is also missing some features STT plugin TTS plugin Audio Transformers plugins Continuous Listening Hybrid Listening Recording Mode Sleep Mode Multiple WakeWords If you need an even lighter implementation, consider hivemind-mic-satellite to also offload wake word to the server","title":"Server requirements"},{"location":"07_voice_relay/#install","text":"Install with pip $ pip install HiveMind-voice-relay","title":"Install"},{"location":"07_voice_relay/#usage","text":"Usage: hivemind-voice-relay [OPTIONS] connect to HiveMind Options: --host TEXT hivemind host --key TEXT Access Key --password TEXT Password for key derivation --port INTEGER HiveMind port number --selfsigned accept self signed certificates --help Show this message and exit.","title":"Usage"},{"location":"07_voice_relay/#configuration","text":"Voice relay is built on top of ovos-simple-listener and ovos-audio , it uses the default OpenVoiceOS configuration ~/.config/mycroft/mycroft.conf Supported plugin types: Plugin Type Description Required Link Microphone Captures voice input Yes Microphone VAD Voice Activity Detection Yes VAD WakeWord Detects wake words for interaction Yes WakeWord G2P grapheme-to-phoneme (G2P), used to simulate mouth movements No G2P Media Playback Plugins Enables media playback (e.g., \"play Metallica\") No Media Playback Plugins OCP Plugins Provides playback support for URLs (e.g., YouTube) No OCP Plugins PHAL Provides platform-specific support (e.g., Mark 1) No PHAL","title":"Configuration"},{"location":"07_voicesat/","text":"HiveMind Voice Satellite OpenVoiceOS Satellite, connect to HiveMind Built on top of ovos-dinkum-listener , ovos-audio and PHAL Install Install dependencies (if needed) sudo apt-get install -y libpulse-dev libasound2-dev Install with pip $ pip install HiveMind-voice-sat Usage Usage: hivemind-voice-sat [OPTIONS] connect to HiveMind Options: --host TEXT hivemind host --key TEXT Access Key --password TEXT Password for key derivation --port INTEGER HiveMind port number --selfsigned accept self signed certificates --help Show this message and exit. Configuration Voice satellite is built on top of ovos-listener and ovos-audio , it uses the same OpenVoiceOS configuration ~/.config/mycroft/mycroft.conf Supported plugins: Plugin Type Description Required Link Microphone Captures voice input Yes Microphone VAD Voice Activity Detection Yes VAD WakeWord Detects wake words for interaction Yes* WakeWord STT speech-to-text (STT) Yes STT TTS text-to-speech (TTS) Yes TTS G2P grapheme-to-phoneme (G2P), used to simulate mouth movements No G2P Media Playback Plugins Enables media playback (e.g., \"play Metallica\") No Media Playback Plugins OCP Plugins Provides playback support for URLs (e.g., YouTube) No OCP Plugins Audio Transformers Processes audio before speech-to-text (STT) No Audio Transformers Dialog Transformers Processes text before text-to-speech (TTS) No Dialog Transformers TTS Transformers Processes audio after text-to-speech (TTS) No TTS Transformers PHAL Provides platform-specific support (e.g., Mark 1) No PHAL can be skipped with continuous listening mode You can optimize your voice satellite for a variety of platforms by selecting different plugin combinations","title":"Voice Satellite"},{"location":"07_voicesat/#hivemind-voice-satellite","text":"OpenVoiceOS Satellite, connect to HiveMind Built on top of ovos-dinkum-listener , ovos-audio and PHAL","title":"HiveMind Voice Satellite"},{"location":"07_voicesat/#install","text":"Install dependencies (if needed) sudo apt-get install -y libpulse-dev libasound2-dev Install with pip $ pip install HiveMind-voice-sat","title":"Install"},{"location":"07_voicesat/#usage","text":"Usage: hivemind-voice-sat [OPTIONS] connect to HiveMind Options: --host TEXT hivemind host --key TEXT Access Key --password TEXT Password for key derivation --port INTEGER HiveMind port number --selfsigned accept self signed certificates --help Show this message and exit.","title":"Usage"},{"location":"07_voicesat/#configuration","text":"Voice satellite is built on top of ovos-listener and ovos-audio , it uses the same OpenVoiceOS configuration ~/.config/mycroft/mycroft.conf Supported plugins: Plugin Type Description Required Link Microphone Captures voice input Yes Microphone VAD Voice Activity Detection Yes VAD WakeWord Detects wake words for interaction Yes* WakeWord STT speech-to-text (STT) Yes STT TTS text-to-speech (TTS) Yes TTS G2P grapheme-to-phoneme (G2P), used to simulate mouth movements No G2P Media Playback Plugins Enables media playback (e.g., \"play Metallica\") No Media Playback Plugins OCP Plugins Provides playback support for URLs (e.g., YouTube) No OCP Plugins Audio Transformers Processes audio before speech-to-text (STT) No Audio Transformers Dialog Transformers Processes text before text-to-speech (TTS) No Dialog Transformers TTS Transformers Processes audio after text-to-speech (TTS) No TTS Transformers PHAL Provides platform-specific support (e.g., Mark 1) No PHAL can be skipped with continuous listening mode You can optimize your voice satellite for a variety of platforms by selecting different plugin combinations","title":"Configuration"},{"location":"08_persona/","text":"Persona this is a hivemind Master node, but it is running ovos-persona instead of connecting to ovos-core you can use this to expose chatbots and LLMs via hivemind, satellites made for hivemind-core should be compatible \u26a0\ufe0f Satellites made specifically for hivemind-listener (Sound server) will not work with hivemind-persona ! Install pip install hivemind-persona ChatGPT Install the OpenAI solver create a chatgpt.json { \"name\": \"ChatGPT\", \"solvers\": [ \"ovos-solver-openai-persona-plugin\" ], \"ovos-solver-openai-persona-plugin\": { \"api_url\": \"<your_local_LocalAI_server_url>\", \"key\": \"<your_OpenAI_key>\", \"persona\": \"helpful, creative, clever, and very friendly.\" } } launch hivemind-persona with the created file hivemind-persona --persona chatgpt.json","title":"Persona Server"},{"location":"08_persona/#persona","text":"this is a hivemind Master node, but it is running ovos-persona instead of connecting to ovos-core you can use this to expose chatbots and LLMs via hivemind, satellites made for hivemind-core should be compatible \u26a0\ufe0f Satellites made specifically for hivemind-listener (Sound server) will not work with hivemind-persona !","title":"Persona"},{"location":"08_persona/#install","text":"pip install hivemind-persona","title":"Install"},{"location":"08_persona/#chatgpt","text":"Install the OpenAI solver create a chatgpt.json { \"name\": \"ChatGPT\", \"solvers\": [ \"ovos-solver-openai-persona-plugin\" ], \"ovos-solver-openai-persona-plugin\": { \"api_url\": \"<your_local_LocalAI_server_url>\", \"key\": \"<your_OpenAI_key>\", \"persona\": \"helpful, creative, clever, and very friendly.\" } } launch hivemind-persona with the created file hivemind-persona --persona chatgpt.json","title":"ChatGPT"},{"location":"09_matrix/","text":"HiveMind - Matrix bridge What is it? Matrix is a chat protocol, it works a little like email, but instantaneous and secure: You need to register an account at a provider Whatever your provider is, you can talk to people using other providers In the same way you can use Outlook or Thunderbird with the same email account, you can use different Matrix apps for the same Matrix account. Install Install from Github Usage Usage: HiveMind-matrix run [OPTIONS] connect a matrix chatroom to hivemind Options: --botname TEXT thehivebot --matrixtoken TEXT syt_dGhl..... --matrixhost TEXT https://matrix.org --room TEXT #hivemind-bots:matrix.org --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --help Show this message and exit.","title":"Matrix"},{"location":"09_matrix/#hivemind-matrix-bridge","text":"What is it? Matrix is a chat protocol, it works a little like email, but instantaneous and secure: You need to register an account at a provider Whatever your provider is, you can talk to people using other providers In the same way you can use Outlook or Thunderbird with the same email account, you can use different Matrix apps for the same Matrix account.","title":"HiveMind - Matrix bridge"},{"location":"09_matrix/#install","text":"Install from Github","title":"Install"},{"location":"09_matrix/#usage","text":"Usage: HiveMind-matrix run [OPTIONS] connect a matrix chatroom to hivemind Options: --botname TEXT thehivebot --matrixtoken TEXT syt_dGhl..... --matrixhost TEXT https://matrix.org --room TEXT #hivemind-bots:matrix.org --key TEXT HiveMind access key (default read from identity file) --password TEXT HiveMind password (default read from identity file) --host TEXT HiveMind host (default read from identity file) --port INTEGER HiveMind port number (default: 5678) --help Show this message and exit.","title":"Usage"},{"location":"10_deltachat/","text":"DeltaChat Bridge Delta Chat is a messaging app that works over e-mail End-to-End Encryption using Autocrypt and CounterMITM protocols, with multiple security audits. Install $ pip install HiveMind-deltachat-bridge Usage $ hm-deltachat-bridge --help usage: __main__.py [-h] --access_key ACCESS_KEY --email EMAIL --password PASSWORD [--crypto_key CRYPTO_KEY] [--name NAME] [--host HOST] [--port PORT] optional arguments: -h, --help show this help message and exit --access_key ACCESS_KEY hivemind access key --email EMAIL deltachat email --password PASSWORD deltachat password --crypto_key CRYPTO_KEY payload encryption key --name NAME human readable device name --host HOST HiveMind host --port PORT HiveMind port number","title":"DeltaChat"},{"location":"10_deltachat/#deltachat-bridge","text":"Delta Chat is a messaging app that works over e-mail End-to-End Encryption using Autocrypt and CounterMITM protocols, with multiple security audits.","title":"DeltaChat Bridge"},{"location":"10_deltachat/#install","text":"$ pip install HiveMind-deltachat-bridge","title":"Install"},{"location":"10_deltachat/#usage","text":"$ hm-deltachat-bridge --help usage: __main__.py [-h] --access_key ACCESS_KEY --email EMAIL --password PASSWORD [--crypto_key CRYPTO_KEY] [--name NAME] [--host HOST] [--port PORT] optional arguments: -h, --help show this help message and exit --access_key ACCESS_KEY hivemind access key --email EMAIL deltachat email --password PASSWORD deltachat password --crypto_key CRYPTO_KEY payload encryption key --name NAME human readable device name --host HOST HiveMind host --port PORT HiveMind port number","title":"Usage"},{"location":"11_devs/","text":"HiveMind makes heavy use of OVOS technology as imported libraries, additional client libraries are provided that implement the HiveMind protocol Libraries If you are implementing a client from scratch, these libraries might be of interest HiveMind-websocket-client (python) HiveMindJs (javascript) ovos-solver-hivemind-plugin python client to chat with hivemind","title":"Libraries"},{"location":"11_devs/#libraries","text":"If you are implementing a client from scratch, these libraries might be of interest HiveMind-websocket-client (python) HiveMindJs (javascript) ovos-solver-hivemind-plugin python client to chat with hivemind","title":"Libraries"},{"location":"12_handshake/","text":"Handshake Protocol This document provides an overview of the handshake protocol used in the HiveMind system, detailing how handshakes are initiated and processed from both the client (slave) and server (master) perspectives. The handshake process establishes a secure connection between a HiveMind master and its slaves. It ensures authentication, optionally using passwords or public/private key pairs, and sets up cryptographic keys for secure communication. For detailed code and various usage examples, you can refer to the Poorman Handshake GitHub Repository . Handshake Types Password-Based Handshake : Utilizes a shared password for authentication. Requires both client and server to know the password beforehand. RSA (Public Key) Handshake : Based on public/private key pairs. The server provides a public key to the client, and the client verifies the server's authenticity. Supports implicit trust for first-time connections (when no previous public key is available). Uses asymmetric encryption to ensure that communication is secure and cannot be intercepted or modified. The symmetric session key (AES) for further communication is transmitted encrypted with RSA public keys. \u26a0\ufe0f RSA Handshake is a work in progress! \ud83d\udea7 Workflow: Server Perspective Send Server Info HELLO \u2709\ufe0f \u27a1\ufe0f Trigger : Sent immediately upon connection establishment. Content : pubkey : Public key for key-based handshake and INTERCOM messages. node_id : A user-friendly identifier for the server. Security : This message is NOT ENCRYPTED \ud83d\udd13. Establish connection parameters HANDSHAKE \u2709\ufe0f \u27a1\ufe0f Trigger : Initiates the handshake process immediately after HELLO message. Content : handshake : Indicates if the connection will be dropped if the client does not finalize the handshake. binarize : Specifies if the server supports the binarization protocol. preshared_key : Indicates the availability of a pre-shared key. password : Indicates the availability of password-based handshake. crypto_required : Specifies if unencrypted messages will be dropped. min_protocol_version : The minimum supported HiveMind protocol version. max_protocol_version : The maximum supported HiveMind protocol version. Security : This message is NOT ENCRYPTED \ud83d\udd13. Initiate Key Exchange \u2b05\ufe0f \u2709\ufe0f HANDSHAKE Trigger : Client initiated handshake in response to previously sent connection parameters. Content : binarize : Specifies if the client supports the binarization protocol. envelope : The handshake envelope to be validated by the server. Behavior : If the client does not respond, the server will skip the handshake step and use the pre-shared cryptographic key directly. Validate the client's envelope using the pre-shared password. Security : This message is NOT ENCRYPTED \ud83d\udd13. Complete Key Exchange HANDSHAKE \u2709\ufe0f \u27a1\ufe0f Trigger : Validated client's envelope and updated the cryptographic key for secure communication. Content : envelope : The handshake envelope to be validated by the client. Security : This message is NOT ENCRYPTED \ud83d\udd13. Receive Client Info \u2b05\ufe0f \u2709\ufe0f HELLO Trigger : Sent after the handshake is complete and encryption is established. Content : session : The client session data. site_id : The client site identifier. pubkey : Public key for INTERCOM messages. Security : This message is ENCRYPTED \ud83d\udd10. Workflow: Client Perspective Receive Server Info \u2b05\ufe0f \u2709\ufe0f HELLO Trigger : Received upon connection establishment. Content : pubkey : The server's public RSA key. node_id : A user-friendly identifier for the server. Security : This message is NOT ENCRYPTED \ud83d\udd13. Establish connection parameters \u2b05\ufe0f \u2709\ufe0f HANDSHAKE Trigger : Received immediately after HELLO message. Content : handshake : Indicates if the connection will be dropped if the client does not finalize the handshake. binarize : Specifies if the server supports the binarization protocol. preshared_key : Indicates the availability of a pre-shared key. password : Indicates the availability of password-based handshake. crypto_required : Specifies if unencrypted messages will be dropped. min_protocol_version : The minimum supported HiveMind protocol version. max_protocol_version : The maximum supported HiveMind protocol version. Security : This message is NOT ENCRYPTED \ud83d\udd13. Initiate Key Exchange HANDSHAKE \u2709\ufe0f \u27a1\ufe0f Trigger : Respond to the server's handshake request. Content : binarize : Specifies if the client supports the binarization protocol. envelope : The handshake envelope to be validated by the server. Security : This message is NOT ENCRYPTED \ud83d\udd13. Complete Key Exchange \u2b05\ufe0f \u2709\ufe0f HANDSHAKE Trigger : On reception of the server's final HANDSHAKE message. Content : envelope : The handshake envelope to be validated by the client. Behavior : Verify the server's authenticity using the shared password. Update the cryptographic key for secure communication. Security : This message is NOT ENCRYPTED \ud83d\udd13. Send Session Data HELLO \u2709\ufe0f \u27a1\ufe0f Trigger : Send session data after encryption is established. Content : session : The client session data. site_id : The client site identifier. pubkey : Public key for INTERCOM messages. Security : This message is ENCRYPTED \ud83d\udd10. Secure Communication After Handshake Upon successful handshake: A shared cryptographic key is established between the server and the client. All further communication between the server and client is encrypted using this symmetric key (AES-256). The session ID ensures continuity and identification in multi-session environments. This guarantees that all data exchanged between the server and the client is protected, even if intercepted by a third party. Error Handling Illegal Messages : Messages not adhering to the protocol are logged, and the connection may be terminated. Authentication Failures : Authentication failures result in handshake termination and rejection of the connection. Skipping Handshake : Handshake can be skipped if a secret key has been previously exchanged out of band For detailed code and various usage examples, please refer to the Poorman Handshake GitHub Repository .","title":"Handshake"},{"location":"12_handshake/#handshake-protocol","text":"This document provides an overview of the handshake protocol used in the HiveMind system, detailing how handshakes are initiated and processed from both the client (slave) and server (master) perspectives. The handshake process establishes a secure connection between a HiveMind master and its slaves. It ensures authentication, optionally using passwords or public/private key pairs, and sets up cryptographic keys for secure communication. For detailed code and various usage examples, you can refer to the Poorman Handshake GitHub Repository .","title":"Handshake Protocol"},{"location":"12_handshake/#handshake-types","text":"Password-Based Handshake : Utilizes a shared password for authentication. Requires both client and server to know the password beforehand. RSA (Public Key) Handshake : Based on public/private key pairs. The server provides a public key to the client, and the client verifies the server's authenticity. Supports implicit trust for first-time connections (when no previous public key is available). Uses asymmetric encryption to ensure that communication is secure and cannot be intercepted or modified. The symmetric session key (AES) for further communication is transmitted encrypted with RSA public keys. \u26a0\ufe0f RSA Handshake is a work in progress! \ud83d\udea7","title":"Handshake Types"},{"location":"12_handshake/#workflow-server-perspective","text":"","title":"Workflow: Server Perspective"},{"location":"12_handshake/#send-server-info-hello","text":"Trigger : Sent immediately upon connection establishment. Content : pubkey : Public key for key-based handshake and INTERCOM messages. node_id : A user-friendly identifier for the server. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Send Server Info HELLO \u2709\ufe0f \u27a1\ufe0f"},{"location":"12_handshake/#establish-connection-parameters-handshake","text":"Trigger : Initiates the handshake process immediately after HELLO message. Content : handshake : Indicates if the connection will be dropped if the client does not finalize the handshake. binarize : Specifies if the server supports the binarization protocol. preshared_key : Indicates the availability of a pre-shared key. password : Indicates the availability of password-based handshake. crypto_required : Specifies if unencrypted messages will be dropped. min_protocol_version : The minimum supported HiveMind protocol version. max_protocol_version : The maximum supported HiveMind protocol version. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Establish connection parameters HANDSHAKE\u2709\ufe0f \u27a1\ufe0f"},{"location":"12_handshake/#initiate-key-exchange-handshake","text":"Trigger : Client initiated handshake in response to previously sent connection parameters. Content : binarize : Specifies if the client supports the binarization protocol. envelope : The handshake envelope to be validated by the server. Behavior : If the client does not respond, the server will skip the handshake step and use the pre-shared cryptographic key directly. Validate the client's envelope using the pre-shared password. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Initiate Key Exchange \u2b05\ufe0f \u2709\ufe0f HANDSHAKE"},{"location":"12_handshake/#complete-key-exchange-handshake","text":"Trigger : Validated client's envelope and updated the cryptographic key for secure communication. Content : envelope : The handshake envelope to be validated by the client. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Complete Key Exchange HANDSHAKE \u2709\ufe0f \u27a1\ufe0f"},{"location":"12_handshake/#receive-client-info-hello","text":"Trigger : Sent after the handshake is complete and encryption is established. Content : session : The client session data. site_id : The client site identifier. pubkey : Public key for INTERCOM messages. Security : This message is ENCRYPTED \ud83d\udd10.","title":"Receive Client Info \u2b05\ufe0f \u2709\ufe0f HELLO"},{"location":"12_handshake/#workflow-client-perspective","text":"","title":"Workflow: Client Perspective"},{"location":"12_handshake/#receive-server-info-hello","text":"Trigger : Received upon connection establishment. Content : pubkey : The server's public RSA key. node_id : A user-friendly identifier for the server. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Receive Server Info \u2b05\ufe0f \u2709\ufe0f HELLO"},{"location":"12_handshake/#establish-connection-parameters-handshake_1","text":"Trigger : Received immediately after HELLO message. Content : handshake : Indicates if the connection will be dropped if the client does not finalize the handshake. binarize : Specifies if the server supports the binarization protocol. preshared_key : Indicates the availability of a pre-shared key. password : Indicates the availability of password-based handshake. crypto_required : Specifies if unencrypted messages will be dropped. min_protocol_version : The minimum supported HiveMind protocol version. max_protocol_version : The maximum supported HiveMind protocol version. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Establish connection parameters \u2b05\ufe0f \u2709\ufe0f HANDSHAKE"},{"location":"12_handshake/#initiate-key-exchange-handshake_1","text":"Trigger : Respond to the server's handshake request. Content : binarize : Specifies if the client supports the binarization protocol. envelope : The handshake envelope to be validated by the server. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Initiate Key Exchange HANDSHAKE \u2709\ufe0f \u27a1\ufe0f"},{"location":"12_handshake/#complete-key-exchange-handshake_1","text":"Trigger : On reception of the server's final HANDSHAKE message. Content : envelope : The handshake envelope to be validated by the client. Behavior : Verify the server's authenticity using the shared password. Update the cryptographic key for secure communication. Security : This message is NOT ENCRYPTED \ud83d\udd13.","title":"Complete Key Exchange \u2b05\ufe0f \u2709\ufe0f HANDSHAKE"},{"location":"12_handshake/#send-session-data-hello","text":"Trigger : Send session data after encryption is established. Content : session : The client session data. site_id : The client site identifier. pubkey : Public key for INTERCOM messages. Security : This message is ENCRYPTED \ud83d\udd10.","title":"Send Session Data HELLO \u2709\ufe0f \u27a1\ufe0f"},{"location":"12_handshake/#secure-communication-after-handshake","text":"Upon successful handshake: A shared cryptographic key is established between the server and the client. All further communication between the server and client is encrypted using this symmetric key (AES-256). The session ID ensures continuity and identification in multi-session environments. This guarantees that all data exchanged between the server and the client is protected, even if intercepted by a third party.","title":"Secure Communication After Handshake"},{"location":"12_handshake/#error-handling","text":"Illegal Messages : Messages not adhering to the protocol are logged, and the connection may be terminated. Authentication Failures : Authentication failures result in handshake termination and rejection of the connection. Skipping Handshake : Handshake can be skipped if a secret key has been previously exchanged out of band For detailed code and various usage examples, please refer to the Poorman Handshake GitHub Repository .","title":"Error Handling"},{"location":"13_mycroft/","text":"OpenVoiceOS Messages The OpenVoiceOS messagebus is considered an internal and private websocket for minds , clients do not connect directly to it. A mind will inject its own context about the originating clients, only responses to the client message will be forwarded, this provides client isolation. A mind will filter incoming and outgoing messages per client, the permissions model of the hivemind is extensive e.g. it might refuse utterances based on the intent This info applies to ovos-core , Hivemind depends on this functionality but it is not part of the hivemind itself. HiveMind responsibility is only to deliver the BUS messages From the POV of the Hivemind you can replace ovos-core with anything as long as you respect the mechanisms below Message Targeting Theory Sources Destinations Skills Message A OpenVoiceOS message consists of a json payload, it contains a type , some data and a context . The context is considered to be metadata and might be changed at any time in transit, the context can contain anything depending on where the message came from, and often is completely empty. You can think of the message context as a sort of session data for a individual interaction, in general messages down the chain keep the context from the original message, most listeners (eg, skills) will only care about type and data . Targeting Theory ovos-core uses the message context to add metadata about the messages themselves, where do they come from and what are they intended for. the Message object provides the following methods: message.forward method, keeps previous context. message continues going to same destination message.reply method swaps \"source\" with \"destination\" message goes back to source The context destination parameter in the original message can be set to a list with any number of intended targets: bus.emit(Message('recognizer_loop:utterance', data, context={'destination': ['audio', 'kde'], 'source': \"remote_service\")) Sources ovos-core injects the context when it emits an utterance, this can be either typed or spoken via OVOS STT service STT will identify itself as audio mycroft.conf defines a list of \"native_sources\" , by default only audio is a native source Destinations Output capable services are ovos-audio (TTS, music...) TTS checks the message context if it's the intended target for the message and will only speak in the following conditions: Explicitly targeted i.e. the destination is native_source (default: \"audio\") destination is set to None destination is missing completely The idea is that for example when the android app is used to access OpenVoiceOS the device at home shouldn't start to speak. TTS will be executed when a native_source (eg, audio ) is the destination A missing destination or if the destination is set to None is interpreted as a multicast and should trigger all output capable processes (be it the ovos-audio process, a web-interface, the KDE plasmoid or maybe the android app) OVOS-Core ovos-core is responsible for managing the routing context, skills do not usually need to worry about any of this intent service will .reply to the original utterance message all skill/intent service messages are .forward (from previous intent service .reply ) Skills OpenVoiceOS skills can do anything, if you are developing/installing a mission critical skill carefully evaluate what it does and evaluate if it is hivemind friendly If a skill emits it's own bus messages it needs to keep message.context around Common issues : skills sending their own messages might not keep message.context or wrongly .reply to it in the context of the Hivemind skills might not be Session aware and keep a shared state between clients, eg. a client may enable a voice game for everyone","title":"OVOS Messages"},{"location":"13_mycroft/#openvoiceos-messages","text":"The OpenVoiceOS messagebus is considered an internal and private websocket for minds , clients do not connect directly to it. A mind will inject its own context about the originating clients, only responses to the client message will be forwarded, this provides client isolation. A mind will filter incoming and outgoing messages per client, the permissions model of the hivemind is extensive e.g. it might refuse utterances based on the intent This info applies to ovos-core , Hivemind depends on this functionality but it is not part of the hivemind itself. HiveMind responsibility is only to deliver the BUS messages From the POV of the Hivemind you can replace ovos-core with anything as long as you respect the mechanisms below Message Targeting Theory Sources Destinations Skills","title":"OpenVoiceOS Messages"},{"location":"13_mycroft/#message","text":"A OpenVoiceOS message consists of a json payload, it contains a type , some data and a context . The context is considered to be metadata and might be changed at any time in transit, the context can contain anything depending on where the message came from, and often is completely empty. You can think of the message context as a sort of session data for a individual interaction, in general messages down the chain keep the context from the original message, most listeners (eg, skills) will only care about type and data .","title":"Message"},{"location":"13_mycroft/#targeting-theory","text":"ovos-core uses the message context to add metadata about the messages themselves, where do they come from and what are they intended for. the Message object provides the following methods: message.forward method, keeps previous context. message continues going to same destination message.reply method swaps \"source\" with \"destination\" message goes back to source The context destination parameter in the original message can be set to a list with any number of intended targets: bus.emit(Message('recognizer_loop:utterance', data, context={'destination': ['audio', 'kde'], 'source': \"remote_service\"))","title":"Targeting Theory"},{"location":"13_mycroft/#sources","text":"ovos-core injects the context when it emits an utterance, this can be either typed or spoken via OVOS STT service STT will identify itself as audio mycroft.conf defines a list of \"native_sources\" , by default only audio is a native source","title":"Sources"},{"location":"13_mycroft/#destinations","text":"Output capable services are ovos-audio (TTS, music...) TTS checks the message context if it's the intended target for the message and will only speak in the following conditions: Explicitly targeted i.e. the destination is native_source (default: \"audio\") destination is set to None destination is missing completely The idea is that for example when the android app is used to access OpenVoiceOS the device at home shouldn't start to speak. TTS will be executed when a native_source (eg, audio ) is the destination A missing destination or if the destination is set to None is interpreted as a multicast and should trigger all output capable processes (be it the ovos-audio process, a web-interface, the KDE plasmoid or maybe the android app)","title":"Destinations"},{"location":"13_mycroft/#ovos-core","text":"ovos-core is responsible for managing the routing context, skills do not usually need to worry about any of this intent service will .reply to the original utterance message all skill/intent service messages are .forward (from previous intent service .reply )","title":"OVOS-Core"},{"location":"13_mycroft/#skills","text":"OpenVoiceOS skills can do anything, if you are developing/installing a mission critical skill carefully evaluate what it does and evaluate if it is hivemind friendly If a skill emits it's own bus messages it needs to keep message.context around Common issues : skills sending their own messages might not keep message.context or wrongly .reply to it in the context of the Hivemind skills might not be Session aware and keep a shared state between clients, eg. a client may enable a voice game for everyone","title":"Skills"},{"location":"14_localhive/","text":"LocalHive \u26a0\ufe0f Proof of Concept : not actively maintained The LocalHive is a hardened OpenVoiceOS skills service, the messagebus is replaced with a hivemind connection *Coming Soon - Github \"security as a requirement, not a feature\" the LocalHive is HTTP only the LocalHive uses no crypto the LocalHive does not require accessKey, instead it only accepts connections coming from 0.0.0.0 the LocalHive rejects all connections not coming from 0.0.0.0 the LocalHive runs in port 6989 skills can not listen to each other's traffic skills can only inject whitelisted messages to LocalHive (by default intents + converse + speak) by default skills only register and trigger intents, nothing else each skill can run in it's own .venv with it's own requirements TODO - skills should be able to request to listen for specific messages, cross skill communication is currently impossible Permissions skills need to be explicitly authorizes to send each message_type UTTERANCES = [\"recognizer_loop:utterance\"] INTENTS = [ \"mycroft.skill.handler.start\", \"mycroft.skill.handler.complete\", \"intent.service.intent.get\", \"intent.service.skills.get\", \"intent.service.active_skills.get\", \"intent.service.adapt.get\", \"intent.service.padatious.get\", \"intent.service.adapt.manifest.get\", \"intent.service.padatious.manifest.get\", \"intent.service.adapt.vocab.manifest.get\", \"intent.service.padatious.entities.manifest.get\", \"register_vocab\", \"register_intent\", \"detach_intent\", \"detach_skill\", \"add_context\", \"remove_context\", \"clear_context\", 'padatious:register_intent', 'padatious:register_entity', \"mycroft.skill.set_cross_context\", \"mycroft.skill.remove_cross_context\" ] CONVERSE = [ \"skill.converse.response\", \"skill.converse.pong\", \"active_skill_request\", \"intent.service.skills.activated\", \"intent.service.skills.deactivated\", ] SPEAK = [\"speak\"] STOP = [\"mycroft.stop\"] DEFAULT = INTENTS + \\ CONVERSE + \\ SPEAK + \\ [\"mycroft.skills.loaded\"] Per Skill Permissions you can allow new messages per skill_id by editing the json file at ~/.config/LocalHive/skill_permissions.json { \"ovos-stop.openvoiceos\": [\"mycroft.stop\"] } Usage At this point of development you need to create python scripts to directly interface with the existing code Running LocalHive from local_hive.service import LocalHiveService from ovos_utils import wait_for_exit_signal if __name__ == \"__main__\": localmind = LocalHiveService() localmind.start() wait_for_exit_signal() Connecting a skill from local_hive.loader import HiveMindExternalSkillWrapper from ovos_utils import wait_for_exit_signal from os.path import join, dirname path = join(dirname(__file__), \"test_skills\", \"mycroft-joke.mycroftai\") skill = HiveMindExternalSkillWrapper(path) wait_for_exit_signal() \"\"\" 2021-05-14 03:23:50.059 | INFO | 44310 | HiveMind-websocket-client | Connected 2021-05-14 03:23:50.111 | INFO | 44310 | mycroft.skills.settings:get_local_settings:83 | /home/user/.config/mycroft/skills/mycroft-joke.mycroftai/settings.json \"\"\"","title":"LocalHive"},{"location":"14_localhive/#localhive","text":"\u26a0\ufe0f Proof of Concept : not actively maintained The LocalHive is a hardened OpenVoiceOS skills service, the messagebus is replaced with a hivemind connection *Coming Soon - Github \"security as a requirement, not a feature\" the LocalHive is HTTP only the LocalHive uses no crypto the LocalHive does not require accessKey, instead it only accepts connections coming from 0.0.0.0 the LocalHive rejects all connections not coming from 0.0.0.0 the LocalHive runs in port 6989 skills can not listen to each other's traffic skills can only inject whitelisted messages to LocalHive (by default intents + converse + speak) by default skills only register and trigger intents, nothing else each skill can run in it's own .venv with it's own requirements TODO - skills should be able to request to listen for specific messages, cross skill communication is currently impossible","title":"LocalHive"},{"location":"14_localhive/#permissions","text":"skills need to be explicitly authorizes to send each message_type UTTERANCES = [\"recognizer_loop:utterance\"] INTENTS = [ \"mycroft.skill.handler.start\", \"mycroft.skill.handler.complete\", \"intent.service.intent.get\", \"intent.service.skills.get\", \"intent.service.active_skills.get\", \"intent.service.adapt.get\", \"intent.service.padatious.get\", \"intent.service.adapt.manifest.get\", \"intent.service.padatious.manifest.get\", \"intent.service.adapt.vocab.manifest.get\", \"intent.service.padatious.entities.manifest.get\", \"register_vocab\", \"register_intent\", \"detach_intent\", \"detach_skill\", \"add_context\", \"remove_context\", \"clear_context\", 'padatious:register_intent', 'padatious:register_entity', \"mycroft.skill.set_cross_context\", \"mycroft.skill.remove_cross_context\" ] CONVERSE = [ \"skill.converse.response\", \"skill.converse.pong\", \"active_skill_request\", \"intent.service.skills.activated\", \"intent.service.skills.deactivated\", ] SPEAK = [\"speak\"] STOP = [\"mycroft.stop\"] DEFAULT = INTENTS + \\ CONVERSE + \\ SPEAK + \\ [\"mycroft.skills.loaded\"]","title":"Permissions"},{"location":"14_localhive/#per-skill-permissions","text":"you can allow new messages per skill_id by editing the json file at ~/.config/LocalHive/skill_permissions.json { \"ovos-stop.openvoiceos\": [\"mycroft.stop\"] }","title":"Per Skill Permissions"},{"location":"14_localhive/#usage","text":"At this point of development you need to create python scripts to directly interface with the existing code","title":"Usage"},{"location":"14_localhive/#running-localhive","text":"from local_hive.service import LocalHiveService from ovos_utils import wait_for_exit_signal if __name__ == \"__main__\": localmind = LocalHiveService() localmind.start() wait_for_exit_signal()","title":"Running LocalHive"},{"location":"14_localhive/#connecting-a-skill","text":"from local_hive.loader import HiveMindExternalSkillWrapper from ovos_utils import wait_for_exit_signal from os.path import join, dirname path = join(dirname(__file__), \"test_skills\", \"mycroft-joke.mycroftai\") skill = HiveMindExternalSkillWrapper(path) wait_for_exit_signal() \"\"\" 2021-05-14 03:23:50.059 | INFO | 44310 | HiveMind-websocket-client | Connected 2021-05-14 03:23:50.111 | INFO | 44310 | mycroft.skills.settings:get_local_settings:83 | /home/user/.config/mycroft/skills/mycroft-joke.mycroftai/settings.json \"\"\"","title":"Connecting a skill"},{"location":"15_nested/","text":"Nested Hives Now that you have a basic hive setup, you can add more Minds to it and connect them to each other. To better understand how minds can interact with each read the protocol Nested Hiveminds in Action To illustrate the power of nested Hiveminds, let's consider a scenario where two housemates, let's call them Mom and Dad, each have their own AI assistant running on OpenVoiceOS, named John and Jane, respectively. While sharing a house and most of their IoT devices, Mom and Dad want to ensure that their AI assistants can control the smart home individually without interfering with each other's commands. To achieve this, they create a Hive for their house, naming it George, with at least one instance of OpenVoiceOS acting as the brain. Mom and Dad then connect their AI assistants, John and Jane, as clients to the George Hive. This setup allows John and Jane to communicate with George individually but not directly with each other. Instead, their messages pass through George, which acts as an intermediary, ensuring proper communication flow. John is connected to Dad's phone and calendar, it knows Dad's favorite songs. This ensures George is not bothered with personal data, and that Dad has a personalized experience. The same holds true for Jane and Mom, Alarms and Music Playlists don't get mixed together It is important to note that as soon as a Hive is decoupled, such as when Mom and Dad split their Hives, they become their own independent Masters again. Now, when Dad instructs his AI assistant to adjust the lights, the message goes through George. Similarly, when Mom asks her AI assistant to set the temperature, the command is routed through George. George becomes the central point of control for the shared devices, enabling independent control for John and Jane. Moreover, if guests visit their house, Mom and Dad can grant them access to George directly, for example by using the voice satellites around the house, or they can create a guest Hive under George temporarily. This flexibility allows for easy integration and disconnection of Hives as required. Nested Hiveminds offer a dynamic and adaptable environment for managing AI systems and devices. This hierarchical organization, with clusters nested within a Master Hive, provides a scalable and efficient framework Permissions Let's further explore the practical applications of nested Hiveminds by introducing another scenario. Imagine that Mom and Dad have a guest staying with them, and this guest, Bob, also has his own AI assistant. To provide Bob with access to the shared smart home functionalities, they allow Bob's AI assistant to connect to the George Hive as a client. However, Mom and Dad want to ensure that Bob's AI assistant has limited permissions within their ecosystem. They configure hivemind-core, acting as a firewall, to restrict Bob's assistant from placing orders or accessing sensitive information from Mom and Dad. This fine-grained control ensures that the guest AI operates within defined boundaries, maintaining privacy and security for all parties involved. Furthermore, consider a scenario where Mom and Dad have children. They can create a separate nested assistant for their kids, granting them access to specific functionalities suitable for their age and requirements. This nested assistant for the kids would have limited permissions and tailored interactions, providing a safe and engaging AI experience while keeping their privacy intact. Nested Hiveminds offer a versatile framework for managing multiple AI assistants and customizing their capabilities based on individual needs and preferences. By configuring access permissions and setting up appropriate firewalls, users can create an ecosystem that ensures privacy, security, and personalized experiences for each participant.","title":"Nested Hives"},{"location":"15_nested/#nested-hives","text":"Now that you have a basic hive setup, you can add more Minds to it and connect them to each other. To better understand how minds can interact with each read the protocol","title":"Nested Hives"},{"location":"15_nested/#nested-hiveminds-in-action","text":"To illustrate the power of nested Hiveminds, let's consider a scenario where two housemates, let's call them Mom and Dad, each have their own AI assistant running on OpenVoiceOS, named John and Jane, respectively. While sharing a house and most of their IoT devices, Mom and Dad want to ensure that their AI assistants can control the smart home individually without interfering with each other's commands. To achieve this, they create a Hive for their house, naming it George, with at least one instance of OpenVoiceOS acting as the brain. Mom and Dad then connect their AI assistants, John and Jane, as clients to the George Hive. This setup allows John and Jane to communicate with George individually but not directly with each other. Instead, their messages pass through George, which acts as an intermediary, ensuring proper communication flow. John is connected to Dad's phone and calendar, it knows Dad's favorite songs. This ensures George is not bothered with personal data, and that Dad has a personalized experience. The same holds true for Jane and Mom, Alarms and Music Playlists don't get mixed together It is important to note that as soon as a Hive is decoupled, such as when Mom and Dad split their Hives, they become their own independent Masters again. Now, when Dad instructs his AI assistant to adjust the lights, the message goes through George. Similarly, when Mom asks her AI assistant to set the temperature, the command is routed through George. George becomes the central point of control for the shared devices, enabling independent control for John and Jane. Moreover, if guests visit their house, Mom and Dad can grant them access to George directly, for example by using the voice satellites around the house, or they can create a guest Hive under George temporarily. This flexibility allows for easy integration and disconnection of Hives as required. Nested Hiveminds offer a dynamic and adaptable environment for managing AI systems and devices. This hierarchical organization, with clusters nested within a Master Hive, provides a scalable and efficient framework","title":"Nested Hiveminds in Action"},{"location":"15_nested/#permissions","text":"Let's further explore the practical applications of nested Hiveminds by introducing another scenario. Imagine that Mom and Dad have a guest staying with them, and this guest, Bob, also has his own AI assistant. To provide Bob with access to the shared smart home functionalities, they allow Bob's AI assistant to connect to the George Hive as a client. However, Mom and Dad want to ensure that Bob's AI assistant has limited permissions within their ecosystem. They configure hivemind-core, acting as a firewall, to restrict Bob's assistant from placing orders or accessing sensitive information from Mom and Dad. This fine-grained control ensures that the guest AI operates within defined boundaries, maintaining privacy and security for all parties involved. Furthermore, consider a scenario where Mom and Dad have children. They can create a separate nested assistant for their kids, granting them access to specific functionalities suitable for their age and requirements. This nested assistant for the kids would have limited permissions and tailored interactions, providing a safe and engaging AI experience while keeping their privacy intact. Nested Hiveminds offer a versatile framework for managing multiple AI assistants and customizing their capabilities based on individual needs and preferences. By configuring access permissions and setting up appropriate firewalls, users can create an ecosystem that ensures privacy, security, and personalized experiences for each participant.","title":"Permissions"},{"location":"16_permissions/","text":"HiveMind Permission System HiveMind's permission system provides fine-grained control over access to resources, such as bus messages, skills, and intents, on a per-client basis. Unlike traditional Role-Based Access Control (RBAC), HiveMind emphasizes client-specific configurations rather than predefined roles, allowing for dynamic and flexible access management. Key Concepts Client-Specific Permissions : Permissions in HiveMind are assigned to individual clients , such as users, devices, or applications. This means that each client can have a unique set of permissions based on its specific needs or restrictions. Permissions control access to bus messages, skills, and intents, enabling dynamic configuration that is more granular and flexible compared to traditional RBAC systems. No Predefined Roles : HiveMind does not rely on predefined roles like \u201cadmin\u201d or \u201cuser.\u201d Instead, each client is configured independently with a tailored set of permissions. For instance, a \u201cbasic client\u201d might have access to general voice commands, while a \u201crestricted client\u201d could have specific skills or intents blocked. Fine-Grained Access Control : Permissions are not just binary (e.g., \u201callowed\u201d or \u201cdenied\u201d). They can be configured at a fine-grained level , allowing administrators to control access to specific resources, such as individual bus messages, skills, and intents. This allows for maximum flexibility in defining which clients have access to what, down to the level of individual interactions. Emergent Roles : While there are no formal roles in HiveMind, roles can emerge through client-specific configurations. For example, a client with broad access might function like an \"admin,\" while another client with limited access could serve as a \"guest.\" These roles are not predefined but are dynamically created based on the client\u2019s permission settings. Comparison to Traditional RBAC Feature Traditional RBAC HiveMind Permission System Role Definition Predefined roles (e.g., admin, user, guest) No predefined roles; permissions are assigned per client Permissions Roles are granted permissions to access resources Permissions are configured on a per-client basis Granularity Roles typically have broad access to resources Permissions are fine-grained, allowing access control over individual resources (messages, skills, intents) Flexibility Less flexible, roles are static Highly flexible, permissions can be dynamically adjusted per client Emergent Roles Predefined roles based on job function or hierarchy Roles emerge based on client-specific configuration How It Works Client Configuration : Each client in the HiveMind ecosystem has a custom configuration that determines the actions it is allowed to perform. This configuration can be adjusted dynamically as needed. Dynamic Permission Assignment : Permissions are assigned on a per-client basis , providing administrators with the ability to specify which bus messages, skills, and intents each client can access or perform. Examples : A trusted client might be granted access to a wide range of skills and intents, including those requiring elevated privileges. A restricted client could have specific actions or skills blacklisted to ensure it operates within a tightly controlled scope. By leveraging client-specific configurations, HiveMind's permission system offers a highly customizable and secure approach to managing access across the ecosystem, allowing administrators to tailor the experience for each client based on their individual needs.","title":"Permissions"},{"location":"16_permissions/#hivemind-permission-system","text":"HiveMind's permission system provides fine-grained control over access to resources, such as bus messages, skills, and intents, on a per-client basis. Unlike traditional Role-Based Access Control (RBAC), HiveMind emphasizes client-specific configurations rather than predefined roles, allowing for dynamic and flexible access management.","title":"HiveMind Permission System"},{"location":"16_permissions/#key-concepts","text":"Client-Specific Permissions : Permissions in HiveMind are assigned to individual clients , such as users, devices, or applications. This means that each client can have a unique set of permissions based on its specific needs or restrictions. Permissions control access to bus messages, skills, and intents, enabling dynamic configuration that is more granular and flexible compared to traditional RBAC systems. No Predefined Roles : HiveMind does not rely on predefined roles like \u201cadmin\u201d or \u201cuser.\u201d Instead, each client is configured independently with a tailored set of permissions. For instance, a \u201cbasic client\u201d might have access to general voice commands, while a \u201crestricted client\u201d could have specific skills or intents blocked. Fine-Grained Access Control : Permissions are not just binary (e.g., \u201callowed\u201d or \u201cdenied\u201d). They can be configured at a fine-grained level , allowing administrators to control access to specific resources, such as individual bus messages, skills, and intents. This allows for maximum flexibility in defining which clients have access to what, down to the level of individual interactions. Emergent Roles : While there are no formal roles in HiveMind, roles can emerge through client-specific configurations. For example, a client with broad access might function like an \"admin,\" while another client with limited access could serve as a \"guest.\" These roles are not predefined but are dynamically created based on the client\u2019s permission settings.","title":"Key Concepts"},{"location":"16_permissions/#comparison-to-traditional-rbac","text":"Feature Traditional RBAC HiveMind Permission System Role Definition Predefined roles (e.g., admin, user, guest) No predefined roles; permissions are assigned per client Permissions Roles are granted permissions to access resources Permissions are configured on a per-client basis Granularity Roles typically have broad access to resources Permissions are fine-grained, allowing access control over individual resources (messages, skills, intents) Flexibility Less flexible, roles are static Highly flexible, permissions can be dynamically adjusted per client Emergent Roles Predefined roles based on job function or hierarchy Roles emerge based on client-specific configuration","title":"Comparison to Traditional RBAC"},{"location":"16_permissions/#how-it-works","text":"Client Configuration : Each client in the HiveMind ecosystem has a custom configuration that determines the actions it is allowed to perform. This configuration can be adjusted dynamically as needed. Dynamic Permission Assignment : Permissions are assigned on a per-client basis , providing administrators with the ability to specify which bus messages, skills, and intents each client can access or perform. Examples : A trusted client might be granted access to a wide range of skills and intents, including those requiring elevated privileges. A restricted client could have specific actions or skills blacklisted to ensure it operates within a tightly controlled scope. By leveraging client-specific configurations, HiveMind's permission system offers a highly customizable and secure approach to managing access across the ecosystem, allowing administrators to tailor the experience for each client based on their individual needs.","title":"How It Works"},{"location":"17_database/","text":"Database Backends hivemind-core supports multiple database backends to store client credentials and settings. Each has its own use case: Backend Use Case Default Location Command Line options JSON (default) Simple, file-based setup for local use ~/.local/share/hivemind-core/clients.json Configurable via --db-name and --db-folder SQLite Lightweight relational DB for single instances ~/.local/share/hivemind-core/clients.db Configurable via --db-name and --db-folder Redis Distributed, high-performance environments localhost:6379 Configurable via --redis-host and --redis-port \u26a0\ufe0f ensure you use the same database parameters when launching hivemind-core and registering clients! How to Choose? For scalability or multi-instance setups, use Redis. For simplicity or single-device environments, use SQLite. For development or to be able to edit the database by hand, use JSON. Security Considerations When using any of these backends, it\u2019s important to implement security practices to safeguard sensitive data. Below are some considerations: 1. JSON (File-Based Storage) Security Risks : As JSON files are stored locally, they can be accessed directly by anyone with access to the file system. Without encryption, the data is vulnerable to unauthorized access. Best Practices : File Permissions : Set restrictive permissions on the .json file to limit access to the user running hivemind-core . Backups : Regularly back up this file to ensure recovery in case of data loss or corruption, while also securing backups with encryption. 2. SQLite (Lightweight Relational Database) Security Risks : SQLite databases are stored in a file, making them susceptible to unauthorized access if file permissions are not properly configured. Best Practices : File Permissions : Ensure the SQLite file is owned by a specific user or group, with read and write access limited to only the user running hivemind-core . Database Backups : Always back up SQLite files securely and store backups in encrypted form. 3. Redis (Distributed High-Performance) Security Risks : Redis is commonly used in distributed setups, which can introduce risks if the Redis server is exposed to the internet or local networks without proper security measures. Best Practices : Authentication : Always configure Redis authentication by setting a strong password using the requirepass directive in the Redis configuration file. Encryption : Use TLS/SSL encryption ( --ssl flag) for data in transit. This ensures that data is encrypted between clients and Redis servers. Access Control : Limit access to Redis to trusted clients and IP addresses by configuring the bind and protected-mode settings in the Redis configuration file. Firewall : Use a firewall to restrict access to Redis from unauthorized networks, ensuring that only trusted systems can communicate with the Redis server. Backups : Redis does not encrypt its persistent storage by default, so ensure that backup files (RDB/AOF) are stored securely and encrypted if necessary. General Database Security Tips: Sensitive Data Storage : Ensure that sensitive data, such as database backups, is stored securely (using encryption) Regular Audits : Periodically audit your database access logs and configurations to ensure no unauthorized access has occurred. Monitoring : Implement monitoring on your database systems to detect any unusual access patterns or unauthorized attempts to connect. By following these best practices, you can ensure that your hivemind-core installation is secure and that client credentials and settings remain protected.","title":"Database"},{"location":"17_database/#database-backends","text":"hivemind-core supports multiple database backends to store client credentials and settings. Each has its own use case: Backend Use Case Default Location Command Line options JSON (default) Simple, file-based setup for local use ~/.local/share/hivemind-core/clients.json Configurable via --db-name and --db-folder SQLite Lightweight relational DB for single instances ~/.local/share/hivemind-core/clients.db Configurable via --db-name and --db-folder Redis Distributed, high-performance environments localhost:6379 Configurable via --redis-host and --redis-port \u26a0\ufe0f ensure you use the same database parameters when launching hivemind-core and registering clients! How to Choose? For scalability or multi-instance setups, use Redis. For simplicity or single-device environments, use SQLite. For development or to be able to edit the database by hand, use JSON.","title":"Database Backends"},{"location":"17_database/#security-considerations","text":"When using any of these backends, it\u2019s important to implement security practices to safeguard sensitive data. Below are some considerations:","title":"Security Considerations"},{"location":"17_database/#1-json-file-based-storage","text":"Security Risks : As JSON files are stored locally, they can be accessed directly by anyone with access to the file system. Without encryption, the data is vulnerable to unauthorized access. Best Practices : File Permissions : Set restrictive permissions on the .json file to limit access to the user running hivemind-core . Backups : Regularly back up this file to ensure recovery in case of data loss or corruption, while also securing backups with encryption.","title":"1. JSON (File-Based Storage)"},{"location":"17_database/#2-sqlite-lightweight-relational-database","text":"Security Risks : SQLite databases are stored in a file, making them susceptible to unauthorized access if file permissions are not properly configured. Best Practices : File Permissions : Ensure the SQLite file is owned by a specific user or group, with read and write access limited to only the user running hivemind-core . Database Backups : Always back up SQLite files securely and store backups in encrypted form.","title":"2. SQLite (Lightweight Relational Database)"},{"location":"17_database/#3-redis-distributed-high-performance","text":"Security Risks : Redis is commonly used in distributed setups, which can introduce risks if the Redis server is exposed to the internet or local networks without proper security measures. Best Practices : Authentication : Always configure Redis authentication by setting a strong password using the requirepass directive in the Redis configuration file. Encryption : Use TLS/SSL encryption ( --ssl flag) for data in transit. This ensures that data is encrypted between clients and Redis servers. Access Control : Limit access to Redis to trusted clients and IP addresses by configuring the bind and protected-mode settings in the Redis configuration file. Firewall : Use a firewall to restrict access to Redis from unauthorized networks, ensuring that only trusted systems can communicate with the Redis server. Backups : Redis does not encrypt its persistent storage by default, so ensure that backup files (RDB/AOF) are stored securely and encrypted if necessary.","title":"3. Redis (Distributed High-Performance)"},{"location":"17_database/#general-database-security-tips","text":"Sensitive Data Storage : Ensure that sensitive data, such as database backups, is stored securely (using encryption) Regular Audits : Periodically audit your database access logs and configurations to ensure no unauthorized access has occurred. Monitoring : Implement monitoring on your database systems to detect any unusual access patterns or unauthorized attempts to connect. By following these best practices, you can ensure that your hivemind-core installation is secure and that client credentials and settings remain protected.","title":"General Database Security Tips:"},{"location":"18_binarization/","text":"Binarization Protocol \u26a0\ufe0f EXPERIMENTAL : subject to change without warning The HiveMind Binarization Protocol is designed to efficiently serialize and deserialize structured messages into compact binary formats for network transmission. This document provides a high-level description of the protocol, including its structure, encoding rules, and the rationale behind key design decisions. The binary format is protocol-versioned to support backward compatibility and future extensions. Protocol Versions The protocol uses an integer version number to indicate supported features and ensure compatibility between clients and servers. The current protocol version is 1 . Any change in functionality or structure requires incrementing the version number. Version-specific functionality: Version 0 : Original protocol design. No binarization, no handshake, only pre-shared crypto_key supported Version 1 : Introduces support for handshakes and binary payloads. Message Types Messages in the HiveMind protocol are categorized into various types, each serving a specific role. These types are encoded as 5-bit unsigned integers, enabling up to 32 distinct types. Examples include: Value Type Description 0 HANDSHAKE Initial connection handshake. 1 BUS Standard message bus. 2 SHARED_BUS Shared bus for multiple nodes. 3 BROADCAST Global message broadcast. 4 PROPAGATE Directed message propagation. 12 BINARY Raw binary payload. Compression Payloads can optionally be compressed using the zlib library. A single bit in the header indicates whether compression is applied. Compressed payloads reduce transmission size but may add slight computational overhead during encoding and decoding. Metadata (HiveMeta) HiveMeta is a reserved field for attaching arbitrary metadata to a message. The metadata is encoded as a byte array, prefixed by its size (in bytes). This allows for extensible features like routing hints or debug information. Binary Message Structure The serialized binary message consists of a header and a payload. All fields are packed to maximize efficiency. The structure is as follows: Header The header contains information about the protocol version, message type, compression, and metadata length. Field Size (bits) Description Start Marker 1 Always 1 . Helps align message boundaries. Versioned Flag 1 Indicates if protocol version is specified. Protocol Version 8 Protocol version (if Versioned Flag is 1 ). Message Type 5 Encoded message type. Compressed Flag 1 Indicates if payload is compressed. Metadata Length 8 Length of metadata in bytes. Metadata Metadata is optional and encodes key-value pairs or other information. If present, it follows the header and is serialized as a byte array. The length of the metadata is specified in the header. Payload The payload represents the core message data. Its format depends on the message type: For standard messages : Encoded as a UTF-8 JSON string. For binary messages : Encoded as raw bytes with an additional 4-bit unsigned integer indicating the binary payload type. Padding To ensure byte alignment, padding bits ( 0 ) are inserted as needed. The total length of the message must be a multiple of 8 bits. Encoding Process Start Marker : Add a single bit set to 1 to signify the start of the message. Header Fields : Add a 1-bit flag to indicate whether the protocol version is included. If the version is included, append the 8-bit protocol version number. Add a 5-bit message type field. Add a 1-bit flag to indicate compression status. Add an 8-bit metadata length field. Metadata : Serialize metadata as a JSON object (if any). Compress the metadata if compression is enabled. Append the serialized metadata. Payload : Serialize the payload according to the message type. Compress the payload if compression is enabled. Append the serialized payload. Padding : Add 0 bits as needed to ensure the total length is a multiple of 8 bits. Decoding Process Alignment : Read bits until encountering the start marker ( 1 ). Header Fields : Read the Versioned Flag and determine if the protocol version is specified. If specified, read the 8-bit protocol version number. Read the 5-bit message type field. Read the Compressed Flag . Read the 8-bit metadata length field. Metadata : Read the specified number of bytes for metadata. Decompress if the Compressed Flag is set. Deserialize the metadata. Payload : Read the remaining bits as the payload. Decompress if the Compressed Flag is set. Deserialize the payload based on the message type. Binary Payloads The protocol provides support for binary payloads, enabling the transmission of non-textual data. Binary payloads are handled based on their designated types, which instruct the HiveMind how to process the binary content. The binary payload type is indicated in the header as a 4 bit unsigned integer after the metadata and before the payload Value Type Description 0 UNDEFINED No information provided about the binary contents. 1 RAW_AUDIO Binary content is raw audio. 2 NUMPY_IMAGE Binary content is an image represented as a numpy array (e.g., webcam picture). 3 FILE Binary is a file to be saved; additional metadata is provided elsewhere. 4 STT_AUDIO_TRANSCRIBE Full audio sentence to perform Speech-to-Text (STT) and return transcripts. 5 STT_AUDIO_HANDLE Full audio sentence to perform STT and handle transcription immediately. 6 TTS_AUDIO Synthesized Text-to-Speech (TTS) audio to be played. \ud83d\udca1 this how how the microphone satellite streams audio to hivemind-listener Examples Serialized Message For a simple message with: Protocol version: 1 Message type: BUS No compression Metadata: {} Payload: {\"type\": \"speak\", \"data\":{\"utterance\": \"Hello\"}} The binary representation might look like this (in bit groups): 1 | 1 | 00000001 | 00001 | 0 | 00000000 | <metadata> | <payload> Where: 1 (Start Marker) 1 (Versioned Flag) 00000001 (Protocol Version) 00001 (Message Type: BUS ) 0 (Compressed Flag) 00000000 (Metadata Length: 0 bytes) <metadata> : Serialized metadata bytes. <payload> : Serialized payload bytes. Binary data For a binary payload with: Protocol version: 1 Message type: BINARY No compression Metadata: {} Binary Payload The binary representation might look like this (in bit groups): 1 | 1 | 00000001 | 00001 | 0 | 00000000 | <metadata> | 0001 | <binary_payload> Where: 1 (Start Marker) 1 (Versioned Flag) 00000001 (Protocol Version) 01100 (Message Type: BINARY ) 0 (Compressed Flag) 00000000 (Metadata Length: 0 bytes) <metadata> : Serialized metadata bytes. 0001 (Binary Type: Raw audio) <payload> : audio bytes. More examples <uint:1=start_marker> | <uint:1=versioned_bit> | <uint:8=protocol_version> | <uint:5=msg_type> | <uint:1=compression_bit> | <uint:8=metadata_len> | <metadata> | <payload> A binarized uncompressed message 1 | 1 | XXXXXXXX | XXXXX | 0 | XXXXXXXX | <metadata> | <payload> A unversioned and compressed binarized message 1 | 0 | XXXXX | 1 | XXXXXXXX | <metadata> | <payload> A binary uncompressed payload message 1 | 1 | XXXXXXXX | 01100 | 0 | XXXXXXXX | <metadata> | XXXX | <payload> A unversioned and compressed binary payload message 1 | 0 | 01100 | 1 | XXXXXXXX | <metadata> | XXXX | <payload> \ud83d\udca1 the binarization scheme allows the protocol to be implemented by just flashing a light Compression Metrics Compression significantly reduces payload size for larger messages but is not always efficient for small messages. Benchmarks indicate a reduction of up to 50% for text-heavy payloads, while small payloads may see negligible benefits.","title":"Binarization"},{"location":"18_binarization/#binarization-protocol","text":"\u26a0\ufe0f EXPERIMENTAL : subject to change without warning The HiveMind Binarization Protocol is designed to efficiently serialize and deserialize structured messages into compact binary formats for network transmission. This document provides a high-level description of the protocol, including its structure, encoding rules, and the rationale behind key design decisions. The binary format is protocol-versioned to support backward compatibility and future extensions.","title":"Binarization Protocol"},{"location":"18_binarization/#protocol-versions","text":"The protocol uses an integer version number to indicate supported features and ensure compatibility between clients and servers. The current protocol version is 1 . Any change in functionality or structure requires incrementing the version number. Version-specific functionality: Version 0 : Original protocol design. No binarization, no handshake, only pre-shared crypto_key supported Version 1 : Introduces support for handshakes and binary payloads.","title":"Protocol Versions"},{"location":"18_binarization/#message-types","text":"Messages in the HiveMind protocol are categorized into various types, each serving a specific role. These types are encoded as 5-bit unsigned integers, enabling up to 32 distinct types. Examples include: Value Type Description 0 HANDSHAKE Initial connection handshake. 1 BUS Standard message bus. 2 SHARED_BUS Shared bus for multiple nodes. 3 BROADCAST Global message broadcast. 4 PROPAGATE Directed message propagation. 12 BINARY Raw binary payload.","title":"Message Types"},{"location":"18_binarization/#compression","text":"Payloads can optionally be compressed using the zlib library. A single bit in the header indicates whether compression is applied. Compressed payloads reduce transmission size but may add slight computational overhead during encoding and decoding.","title":"Compression"},{"location":"18_binarization/#metadata-hivemeta","text":"HiveMeta is a reserved field for attaching arbitrary metadata to a message. The metadata is encoded as a byte array, prefixed by its size (in bytes). This allows for extensible features like routing hints or debug information.","title":"Metadata (HiveMeta)"},{"location":"18_binarization/#binary-message-structure","text":"The serialized binary message consists of a header and a payload. All fields are packed to maximize efficiency. The structure is as follows:","title":"Binary Message Structure"},{"location":"18_binarization/#header","text":"The header contains information about the protocol version, message type, compression, and metadata length. Field Size (bits) Description Start Marker 1 Always 1 . Helps align message boundaries. Versioned Flag 1 Indicates if protocol version is specified. Protocol Version 8 Protocol version (if Versioned Flag is 1 ). Message Type 5 Encoded message type. Compressed Flag 1 Indicates if payload is compressed. Metadata Length 8 Length of metadata in bytes.","title":"Header"},{"location":"18_binarization/#metadata","text":"Metadata is optional and encodes key-value pairs or other information. If present, it follows the header and is serialized as a byte array. The length of the metadata is specified in the header.","title":"Metadata"},{"location":"18_binarization/#payload","text":"The payload represents the core message data. Its format depends on the message type: For standard messages : Encoded as a UTF-8 JSON string. For binary messages : Encoded as raw bytes with an additional 4-bit unsigned integer indicating the binary payload type.","title":"Payload"},{"location":"18_binarization/#padding","text":"To ensure byte alignment, padding bits ( 0 ) are inserted as needed. The total length of the message must be a multiple of 8 bits.","title":"Padding"},{"location":"18_binarization/#encoding-process","text":"Start Marker : Add a single bit set to 1 to signify the start of the message. Header Fields : Add a 1-bit flag to indicate whether the protocol version is included. If the version is included, append the 8-bit protocol version number. Add a 5-bit message type field. Add a 1-bit flag to indicate compression status. Add an 8-bit metadata length field. Metadata : Serialize metadata as a JSON object (if any). Compress the metadata if compression is enabled. Append the serialized metadata. Payload : Serialize the payload according to the message type. Compress the payload if compression is enabled. Append the serialized payload. Padding : Add 0 bits as needed to ensure the total length is a multiple of 8 bits.","title":"Encoding Process"},{"location":"18_binarization/#decoding-process","text":"Alignment : Read bits until encountering the start marker ( 1 ). Header Fields : Read the Versioned Flag and determine if the protocol version is specified. If specified, read the 8-bit protocol version number. Read the 5-bit message type field. Read the Compressed Flag . Read the 8-bit metadata length field. Metadata : Read the specified number of bytes for metadata. Decompress if the Compressed Flag is set. Deserialize the metadata. Payload : Read the remaining bits as the payload. Decompress if the Compressed Flag is set. Deserialize the payload based on the message type.","title":"Decoding Process"},{"location":"18_binarization/#binary-payloads","text":"The protocol provides support for binary payloads, enabling the transmission of non-textual data. Binary payloads are handled based on their designated types, which instruct the HiveMind how to process the binary content. The binary payload type is indicated in the header as a 4 bit unsigned integer after the metadata and before the payload Value Type Description 0 UNDEFINED No information provided about the binary contents. 1 RAW_AUDIO Binary content is raw audio. 2 NUMPY_IMAGE Binary content is an image represented as a numpy array (e.g., webcam picture). 3 FILE Binary is a file to be saved; additional metadata is provided elsewhere. 4 STT_AUDIO_TRANSCRIBE Full audio sentence to perform Speech-to-Text (STT) and return transcripts. 5 STT_AUDIO_HANDLE Full audio sentence to perform STT and handle transcription immediately. 6 TTS_AUDIO Synthesized Text-to-Speech (TTS) audio to be played. \ud83d\udca1 this how how the microphone satellite streams audio to hivemind-listener","title":"Binary Payloads"},{"location":"18_binarization/#examples","text":"","title":"Examples"},{"location":"18_binarization/#serialized-message","text":"For a simple message with: Protocol version: 1 Message type: BUS No compression Metadata: {} Payload: {\"type\": \"speak\", \"data\":{\"utterance\": \"Hello\"}} The binary representation might look like this (in bit groups): 1 | 1 | 00000001 | 00001 | 0 | 00000000 | <metadata> | <payload> Where: 1 (Start Marker) 1 (Versioned Flag) 00000001 (Protocol Version) 00001 (Message Type: BUS ) 0 (Compressed Flag) 00000000 (Metadata Length: 0 bytes) <metadata> : Serialized metadata bytes. <payload> : Serialized payload bytes.","title":"Serialized Message"},{"location":"18_binarization/#binary-data","text":"For a binary payload with: Protocol version: 1 Message type: BINARY No compression Metadata: {} Binary Payload The binary representation might look like this (in bit groups): 1 | 1 | 00000001 | 00001 | 0 | 00000000 | <metadata> | 0001 | <binary_payload> Where: 1 (Start Marker) 1 (Versioned Flag) 00000001 (Protocol Version) 01100 (Message Type: BINARY ) 0 (Compressed Flag) 00000000 (Metadata Length: 0 bytes) <metadata> : Serialized metadata bytes. 0001 (Binary Type: Raw audio) <payload> : audio bytes.","title":"Binary data"},{"location":"18_binarization/#more-examples","text":"<uint:1=start_marker> | <uint:1=versioned_bit> | <uint:8=protocol_version> | <uint:5=msg_type> | <uint:1=compression_bit> | <uint:8=metadata_len> | <metadata> | <payload> A binarized uncompressed message 1 | 1 | XXXXXXXX | XXXXX | 0 | XXXXXXXX | <metadata> | <payload> A unversioned and compressed binarized message 1 | 0 | XXXXX | 1 | XXXXXXXX | <metadata> | <payload> A binary uncompressed payload message 1 | 1 | XXXXXXXX | 01100 | 0 | XXXXXXXX | <metadata> | XXXX | <payload> A unversioned and compressed binary payload message 1 | 0 | 01100 | 1 | XXXXXXXX | <metadata> | XXXX | <payload> \ud83d\udca1 the binarization scheme allows the protocol to be implemented by just flashing a light","title":"More examples"},{"location":"18_binarization/#compression-metrics","text":"Compression significantly reduces payload size for larger messages but is not always efficient for small messages. Benchmarks indicate a reduction of up to 50% for text-heavy payloads, while small payloads may see negligible benefits.","title":"Compression Metrics"},{"location":"19_crypto/","text":"Encryption HiveMind ensures secure communication between devices by using modern cryptographic techniques. This page provides an overview of how messages are encrypted in transit, the structure of encrypted messages, and the process of encryption key generation. End-to-End Encryption : Messages are encrypted on the sender's device and decrypted only on the receiver's device, ensuring complete confidentiality. Mutual Authentication : The identity verification step ensures that both devices share the same credentials and trust each other. Resistance to Replay Attacks : The use of unique IVs for each message prevents attackers from reusing captured messages. Strong Key Derivation : By leveraging PBKDF2 and a shared salt, HiveMind protects against brute-force and dictionary attacks. Terminology Before diving into the details, here are key terms used in this documentation: Plaintext : Unencrypted data, the original readable content before encryption. Ciphertext : Encrypted data, unreadable without the decryption key. AES : Advanced Encryption Standard, a symmetric encryption algorithm. GCM : Galois/Counter Mode, a mode of operation for AES that provides both encryption and message authentication. IV : Initialization vector (sometimes called nonce ), a unique value used to initialize encryption and ensure message uniqueness. MAC : Message Authentication Code (sometimes called tag or Integrity Check Value ( ICV )), used to verify the authenticity and integrity of a message. Salt : A random value used during key derivation to ensure unique and secure key generation, even with repeated passwords. SHA-2 : A family of cryptographic hash functions, used for generating hash values (e.g., SHA-256 is used in HiveMind). PBKDF2 : Password-Based Key Derivation Function 2, a cryptographic function that strengthens passwords by applying hashing multiple times to derive secure keys. Overview HiveMind uses AES-GCM (Advanced Encryption Standard in Galois/Counter Mode) for authenticated encryption of messages in transit. This method provides both confidentiality (protecting the message content) and integrity (ensuring that messages have not been tampered with during transmission). To securely exchange messages, HiveMind leverages a key derivation and exchange mechanism that avoids directly sharing sensitive credentials, ensuring secure key generation and agreement between devices. Encryption in Transit When two devices communicate over HiveMind, all messages are encrypted before being transmitted over the network. This prevents eavesdropping and ensures that any intercepted messages are unreadable without the appropriate key. Each encrypted message contains the following components: { \"ciphertext\": \"<encrypted_message>\", \"tag\": \"<authentication_tag>\", \"nonce\": \"<initialization_vector>\" } Ciphertext : The encrypted form of the original plaintext message. Tag : A message authentication code (MAC) that ensures the integrity and authenticity of the message. Nonce (IV) : A unique initialization vector used for encryption. It ensures that each message is encrypted uniquely, even if the same key and plaintext are reused. The nonce and tag are included in the message unencrypted, while the ciphertext remains confidential. This allows the receiving device to verify and decrypt the message. Key Generation and Exchange To securely encrypt and decrypt messages, HiveMind uses a shared secret key. This key is never transmitted directly but is derived independently by each device using the following steps: \ud83d\udca1 Protocol V0 starts directly with the pre-shared key, Protocol V1 still supports this usage by simply ignoring the handshake initated by the server 1. Handshake and Identity Verification Each device generates a hash-based subkey (HSUB) using: A randomly generated initialization vector (IV) . The user's password (or pre-shared secret). A cryptographic hash function, such as SHA-256 . Devices exchange their HSUB and IV values over the network. Upon receiving the other's HSUB , each device regenerates it locally using the received IV and its own password. If the computed and received HSUB match, the devices verify each other's identity. 2. Deriving a Common Salt A shared salt is generated by XORing the IV values exchanged during the handshake: Salt = IV_A \u2295 IV_B This salt ensures that each session has a unique basis for key derivation. 3. Key Derivation Both devices derive a common secret key using the following inputs: The salt from the previous step. The user's password . The key derivation process uses PBKDF2 (Password-Based Key Derivation Function 2) with HMAC-SHA256 to produce a cryptographically strong key. This approach ensures that both devices independently derive the same encryption key without directly transmitting it over the network. Secure Message Exchange Once the secret key is derived, it is used to encrypt and decrypt all messages exchanged between devices. The process is as follows: Encryption : The sending device uses the secret key to encrypt the plaintext message using AES-GCM. The resulting ciphertext, along with the nonce and tag , is packaged into a message and sent over the network. Decryption : The receiving device extracts the ciphertext , nonce , and tag from the message. Using the same secret key, it decrypts the ciphertext and verifies the message integrity using the tag .","title":"Encryption"},{"location":"19_crypto/#encryption","text":"HiveMind ensures secure communication between devices by using modern cryptographic techniques. This page provides an overview of how messages are encrypted in transit, the structure of encrypted messages, and the process of encryption key generation. End-to-End Encryption : Messages are encrypted on the sender's device and decrypted only on the receiver's device, ensuring complete confidentiality. Mutual Authentication : The identity verification step ensures that both devices share the same credentials and trust each other. Resistance to Replay Attacks : The use of unique IVs for each message prevents attackers from reusing captured messages. Strong Key Derivation : By leveraging PBKDF2 and a shared salt, HiveMind protects against brute-force and dictionary attacks.","title":"Encryption"},{"location":"19_crypto/#terminology","text":"Before diving into the details, here are key terms used in this documentation: Plaintext : Unencrypted data, the original readable content before encryption. Ciphertext : Encrypted data, unreadable without the decryption key. AES : Advanced Encryption Standard, a symmetric encryption algorithm. GCM : Galois/Counter Mode, a mode of operation for AES that provides both encryption and message authentication. IV : Initialization vector (sometimes called nonce ), a unique value used to initialize encryption and ensure message uniqueness. MAC : Message Authentication Code (sometimes called tag or Integrity Check Value ( ICV )), used to verify the authenticity and integrity of a message. Salt : A random value used during key derivation to ensure unique and secure key generation, even with repeated passwords. SHA-2 : A family of cryptographic hash functions, used for generating hash values (e.g., SHA-256 is used in HiveMind). PBKDF2 : Password-Based Key Derivation Function 2, a cryptographic function that strengthens passwords by applying hashing multiple times to derive secure keys.","title":"Terminology"},{"location":"19_crypto/#overview","text":"HiveMind uses AES-GCM (Advanced Encryption Standard in Galois/Counter Mode) for authenticated encryption of messages in transit. This method provides both confidentiality (protecting the message content) and integrity (ensuring that messages have not been tampered with during transmission). To securely exchange messages, HiveMind leverages a key derivation and exchange mechanism that avoids directly sharing sensitive credentials, ensuring secure key generation and agreement between devices.","title":"Overview"},{"location":"19_crypto/#encryption-in-transit","text":"When two devices communicate over HiveMind, all messages are encrypted before being transmitted over the network. This prevents eavesdropping and ensures that any intercepted messages are unreadable without the appropriate key. Each encrypted message contains the following components: { \"ciphertext\": \"<encrypted_message>\", \"tag\": \"<authentication_tag>\", \"nonce\": \"<initialization_vector>\" } Ciphertext : The encrypted form of the original plaintext message. Tag : A message authentication code (MAC) that ensures the integrity and authenticity of the message. Nonce (IV) : A unique initialization vector used for encryption. It ensures that each message is encrypted uniquely, even if the same key and plaintext are reused. The nonce and tag are included in the message unencrypted, while the ciphertext remains confidential. This allows the receiving device to verify and decrypt the message.","title":"Encryption in Transit"},{"location":"19_crypto/#key-generation-and-exchange","text":"To securely encrypt and decrypt messages, HiveMind uses a shared secret key. This key is never transmitted directly but is derived independently by each device using the following steps: \ud83d\udca1 Protocol V0 starts directly with the pre-shared key, Protocol V1 still supports this usage by simply ignoring the handshake initated by the server","title":"Key Generation and Exchange"},{"location":"19_crypto/#1-handshake-and-identity-verification","text":"Each device generates a hash-based subkey (HSUB) using: A randomly generated initialization vector (IV) . The user's password (or pre-shared secret). A cryptographic hash function, such as SHA-256 . Devices exchange their HSUB and IV values over the network. Upon receiving the other's HSUB , each device regenerates it locally using the received IV and its own password. If the computed and received HSUB match, the devices verify each other's identity.","title":"1. Handshake and Identity Verification"},{"location":"19_crypto/#2-deriving-a-common-salt","text":"A shared salt is generated by XORing the IV values exchanged during the handshake: Salt = IV_A \u2295 IV_B This salt ensures that each session has a unique basis for key derivation.","title":"2. Deriving a Common Salt"},{"location":"19_crypto/#3-key-derivation","text":"Both devices derive a common secret key using the following inputs: The salt from the previous step. The user's password . The key derivation process uses PBKDF2 (Password-Based Key Derivation Function 2) with HMAC-SHA256 to produce a cryptographically strong key. This approach ensures that both devices independently derive the same encryption key without directly transmitting it over the network.","title":"3. Key Derivation"},{"location":"19_crypto/#secure-message-exchange","text":"Once the secret key is derived, it is used to encrypt and decrypt all messages exchanged between devices. The process is as follows: Encryption : The sending device uses the secret key to encrypt the plaintext message using AES-GCM. The resulting ciphertext, along with the nonce and tag , is packaged into a message and sent over the network. Decryption : The receiving device extracts the ciphertext , nonce , and tag from the message. Using the same secret key, it decrypts the ciphertext and verifies the message integrity using the tag .","title":"Secure Message Exchange"},{"location":"TODO/","text":"wormhole node its actually 2 nodes node 1 drops messages in place X node 2 retrieves messages from place X messages are literal hive protocol messages X is any transport layer, literally anything nodes might not know each other at all as long as they know how to retrieve stuff the objective is hiding location any master that sees node 2 just thinks it is node 1! implementations: - usenet anon message boards (read # post # ) storage node any node can leave a payload in a storage node + associated proof optionally encrypted (recommended) a proof is a text string + same string encrypted with \"receiver pubkey\" any node can request any (encrypted) file the storage node will send the encrypted proof the node sends the decrypted proof if both match the node proves it is the receiver the storage node sends the file note: connections to these nodes should be ephemeral, ie, nodes disconnect once the deed is done note2: these can be public and hosted by random people, if you trust PGP rendevouz node a variation of the above, imagine a scenario with a very very large hive, maybe some nodes are even public or half way across the world node fires a \"query\" hive message message contains the address of a storage node the mind should drop the answer in the response doesnt need to travel all the way back optionally include node pubkey (may have been shared out of band) node checks the pre defined storage node every timestep until it receives an answer depending on relationship with storage node it might be possible to use events instead a storage node can be a http api (see http bridge TODO) where did the answer come from?","title":"TODO"},{"location":"TODO/#wormhole-node","text":"its actually 2 nodes node 1 drops messages in place X node 2 retrieves messages from place X messages are literal hive protocol messages X is any transport layer, literally anything nodes might not know each other at all as long as they know how to retrieve stuff the objective is hiding location any master that sees node 2 just thinks it is node 1! implementations: - usenet anon message boards (read # post # )","title":"wormhole node"},{"location":"TODO/#storage-node","text":"any node can leave a payload in a storage node + associated proof optionally encrypted (recommended) a proof is a text string + same string encrypted with \"receiver pubkey\" any node can request any (encrypted) file the storage node will send the encrypted proof the node sends the decrypted proof if both match the node proves it is the receiver the storage node sends the file note: connections to these nodes should be ephemeral, ie, nodes disconnect once the deed is done note2: these can be public and hosted by random people, if you trust PGP","title":"storage node"},{"location":"TODO/#rendevouz-node","text":"a variation of the above, imagine a scenario with a very very large hive, maybe some nodes are even public or half way across the world node fires a \"query\" hive message message contains the address of a storage node the mind should drop the answer in the response doesnt need to travel all the way back optionally include node pubkey (may have been shared out of band) node checks the pre defined storage node every timestep until it receives an answer depending on relationship with storage node it might be possible to use events instead a storage node can be a http api (see http bridge TODO) where did the answer come from?","title":"rendevouz node"},{"location":"gpt_bridges/","text":"Exploring HiveMind Web Chat Interface and Bridges: Extending AI Capabilities In the ever-expanding landscape of AI and interconnected systems, the HiveMind framework continues to push boundaries and open up new possibilities. As part of the HiveMind ecosystem, the HiveMind Web Chat Interface and HiveMind Bridges offer exciting avenues for integrating AI capabilities into various platforms and enabling seamless communication with AI assistants. In this blog post, we will delve into the world of HiveMind Bridges and explore how the HiveMind Web Chat Interface enhances user experiences. HiveMind Bridges: Connecting the Dots HiveMind Bridges serve as connectors between external platforms and the HiveMind network. These bridges act as terminals, enabling communication with the HiveMind infrastructure. With the support of various protocols such as Matrix, Mattermost Bridge , HackChat Bridge , DeltaChat Bridge , email, and more, HiveMind Bridges extend the reach of AI assistants and allow them to interact with users through familiar channels. Each bridge behaves like a secure intermediary, ensuring the safety and privacy of communications. They maintain their own session and permissions, allowing them to answer specific users or adhere to custom rules defined within the bridge. This flexibility makes it possible to integrate AI assistants seamlessly into existing communication platforms, expanding their capabilities and enhancing user interactions. HiveMind Web Chat Interface: Unleashing AI Potential The HiveMind Webchat Interface, powered by HiveMindJs provides a user-friendly and versatile solution for connecting to the HiveMind network. This JavaScript library enables direct communication with the HiveMind infrastructure when access keys are available in the browser environment. For instance, a login page with HiveMind access keys can leverage HiveMindJS to establish a secure connection, granting users access to AI functionalities seamlessly. However, there may be situations where exposing HiveMind login keys in the browser is not desirable for security reasons. In such cases, a HiveMind Bridge comes into play. Acting as a middle layer, the bridge node safely connects to the HiveMind network on a server , while the browser interacts solely with the bridge. This architecture ensures that sensitive information remains protected, and communication with the HiveMind is conducted securely. Integrating a Chatbot with Existing Business Platforms Let's consider a practical example of leveraging the HiveMind ecosystem to integrate a chatbot into an existing business platform. Suppose you have a thriving online platform where users engage with your products or services. By hosting HiveMind-Core, Ovos-Core, and a HiveMind Bridge, you can seamlessly integrate a chatbot powered by AI into your platform. The HiveMind Bridge, acting as the intermediary, facilitates communication between your platform and the HiveMind network. Users can interact with the chatbot, ask questions, seek assistance, or perform specific actions directly from within your platform. The chatbot, backed by the extensive capabilities of the HiveMind infrastructure, can provide personalized responses, offer recommendations, and enhance user experiences. By incorporating a chatbot into your existing platform, you streamline customer support, automate certain processes, and deliver a more interactive and efficient user experience. The HiveMind ecosystem, with its powerful AI capabilities and flexible bridges, empowers businesses to leverage AI technologies seamlessly, unlocking new opportunities for growth and innovation. Conclusion The HiveMind Web Chat Interface and HiveMind Bridges revolutionize the way AI assistants integrate into diverse platforms. Through bridges, AI systems gain access to popular communication channels, while the HiveMind Web Chat Interface facilitates direct communication with the HiveMind network. With the ability to securely connect to the HiveMind infrastructure and extend AI capabilities, businesses can create immersive, interactive, and intelligent experiences for their users. As the HiveMind ecosystem continues to evolve, we anticipate even more innovative use cases and seamless integrations. The future holds immense potential for expanding AI's reach and enhancing human-AI collaboration. With","title":"Exploring HiveMind Web Chat Interface and Bridges: Extending AI Capabilities"},{"location":"gpt_bridges/#exploring-hivemind-web-chat-interface-and-bridges-extending-ai-capabilities","text":"In the ever-expanding landscape of AI and interconnected systems, the HiveMind framework continues to push boundaries and open up new possibilities. As part of the HiveMind ecosystem, the HiveMind Web Chat Interface and HiveMind Bridges offer exciting avenues for integrating AI capabilities into various platforms and enabling seamless communication with AI assistants. In this blog post, we will delve into the world of HiveMind Bridges and explore how the HiveMind Web Chat Interface enhances user experiences.","title":"Exploring HiveMind Web Chat Interface and Bridges: Extending AI Capabilities"},{"location":"gpt_bridges/#hivemind-bridges-connecting-the-dots","text":"HiveMind Bridges serve as connectors between external platforms and the HiveMind network. These bridges act as terminals, enabling communication with the HiveMind infrastructure. With the support of various protocols such as Matrix, Mattermost Bridge , HackChat Bridge , DeltaChat Bridge , email, and more, HiveMind Bridges extend the reach of AI assistants and allow them to interact with users through familiar channels. Each bridge behaves like a secure intermediary, ensuring the safety and privacy of communications. They maintain their own session and permissions, allowing them to answer specific users or adhere to custom rules defined within the bridge. This flexibility makes it possible to integrate AI assistants seamlessly into existing communication platforms, expanding their capabilities and enhancing user interactions.","title":"HiveMind Bridges: Connecting the Dots"},{"location":"gpt_bridges/#hivemind-web-chat-interface-unleashing-ai-potential","text":"The HiveMind Webchat Interface, powered by HiveMindJs provides a user-friendly and versatile solution for connecting to the HiveMind network. This JavaScript library enables direct communication with the HiveMind infrastructure when access keys are available in the browser environment. For instance, a login page with HiveMind access keys can leverage HiveMindJS to establish a secure connection, granting users access to AI functionalities seamlessly. However, there may be situations where exposing HiveMind login keys in the browser is not desirable for security reasons. In such cases, a HiveMind Bridge comes into play. Acting as a middle layer, the bridge node safely connects to the HiveMind network on a server , while the browser interacts solely with the bridge. This architecture ensures that sensitive information remains protected, and communication with the HiveMind is conducted securely.","title":"HiveMind Web Chat Interface: Unleashing AI Potential"},{"location":"gpt_bridges/#integrating-a-chatbot-with-existing-business-platforms","text":"Let's consider a practical example of leveraging the HiveMind ecosystem to integrate a chatbot into an existing business platform. Suppose you have a thriving online platform where users engage with your products or services. By hosting HiveMind-Core, Ovos-Core, and a HiveMind Bridge, you can seamlessly integrate a chatbot powered by AI into your platform. The HiveMind Bridge, acting as the intermediary, facilitates communication between your platform and the HiveMind network. Users can interact with the chatbot, ask questions, seek assistance, or perform specific actions directly from within your platform. The chatbot, backed by the extensive capabilities of the HiveMind infrastructure, can provide personalized responses, offer recommendations, and enhance user experiences. By incorporating a chatbot into your existing platform, you streamline customer support, automate certain processes, and deliver a more interactive and efficient user experience. The HiveMind ecosystem, with its powerful AI capabilities and flexible bridges, empowers businesses to leverage AI technologies seamlessly, unlocking new opportunities for growth and innovation.","title":"Integrating a Chatbot with Existing Business Platforms"},{"location":"gpt_bridges/#conclusion","text":"The HiveMind Web Chat Interface and HiveMind Bridges revolutionize the way AI assistants integrate into diverse platforms. Through bridges, AI systems gain access to popular communication channels, while the HiveMind Web Chat Interface facilitates direct communication with the HiveMind network. With the ability to securely connect to the HiveMind infrastructure and extend AI capabilities, businesses can create immersive, interactive, and intelligent experiences for their users. As the HiveMind ecosystem continues to evolve, we anticipate even more innovative use cases and seamless integrations. The future holds immense potential for expanding AI's reach and enhancing human-AI collaboration. With","title":"Conclusion"},{"location":"gpt_eli5/","text":"ELI5 Imagine you and your friends want to play a game together, but you're all in different rooms. To make it possible to play together, you need to follow some rules and communicate with each other. That's what the HiveMind protocol does for voice assistants. The HiveMind protocol is like a set of rules that voice assistants use to talk to each other and work together. It helps them understand each other and coordinate their actions. Just like in the game, the voice assistants need to agree on how they will communicate and what they can do together. For example, let's say you and your friend have voice assistants. They use the HiveMind protocol to talk to each other. Your voice assistant can send messages to your friend's voice assistant, and vice versa. These messages can be commands, questions, or even just saying \"hello.\" The HiveMind protocol also helps the voice assistants recognize each other. They have special identities that let them know who is who. It's like having name tags so they can say, \"Hi, I'm Voice Assistant A!\" or \"Nice to meet you, Voice Assistant B!\" To follow the HiveMind protocol, the voice assistants use a special language that they all understand. It's like having a secret code that only they know. This language helps them communicate in a way that makes sense to them. The HiveMind protocol also includes some safety measures. Just like you have rules to keep you safe when playing games, the voice assistants have rules too. They make sure that only trusted voice assistants can join and participate. They use things like passwords and encryption to keep things secure. So, the HiveMind protocol is like a set of rules and a special language that voice assistants use to talk to each other, understand each other, and work together. It helps them play the game of being voice assistants in a fun and safe way!","title":"ELI5"},{"location":"gpt_eli5/#eli5","text":"Imagine you and your friends want to play a game together, but you're all in different rooms. To make it possible to play together, you need to follow some rules and communicate with each other. That's what the HiveMind protocol does for voice assistants. The HiveMind protocol is like a set of rules that voice assistants use to talk to each other and work together. It helps them understand each other and coordinate their actions. Just like in the game, the voice assistants need to agree on how they will communicate and what they can do together. For example, let's say you and your friend have voice assistants. They use the HiveMind protocol to talk to each other. Your voice assistant can send messages to your friend's voice assistant, and vice versa. These messages can be commands, questions, or even just saying \"hello.\" The HiveMind protocol also helps the voice assistants recognize each other. They have special identities that let them know who is who. It's like having name tags so they can say, \"Hi, I'm Voice Assistant A!\" or \"Nice to meet you, Voice Assistant B!\" To follow the HiveMind protocol, the voice assistants use a special language that they all understand. It's like having a secret code that only they know. This language helps them communicate in a way that makes sense to them. The HiveMind protocol also includes some safety measures. Just like you have rules to keep you safe when playing games, the voice assistants have rules too. They make sure that only trusted voice assistants can join and participate. They use things like passwords and encryption to keep things secure. So, the HiveMind protocol is like a set of rules and a special language that voice assistants use to talk to each other, understand each other, and work together. It helps them play the game of being voice assistants in a fun and safe way!","title":"ELI5"}]}